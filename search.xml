<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[函数去抖动之debounce]]></title>
      <url>%2F2017%2F02%2F25%2F%E5%87%BD%E6%95%B0%E5%8E%BB%E6%8A%96%E5%8A%A8%E4%B9%8Bdebounce%2F</url>
      <content type="text"><![CDATA[snippet-key @js function debounce underscore v1.7.0相关的源码剖123456789101112131415161718192021222324252627282930313233343536// underscore v1.7.0相关的源码剖_.debounce = function(func, wait, immediate) &#123; // immediate默认为false var timeout, args, context, timestamp, result; var later = function() &#123; // 当wait指定的时间间隔期间多次调用_.debounce返回的函数，则会不断更新timestamp的值，导致last &lt; wait &amp;&amp; last &gt;= 0一直为true，从而不断启动新的计时器延时执行func var last = _.now() - timestamp; if (last &lt; wait &amp;&amp; last &gt;= 0) &#123; timeout = setTimeout(later, wait - last); &#125; else &#123; timeout = null; if (!immediate) &#123; result = func.apply(context, args); if (!timeout) context = args = null; &#125; &#125; &#125;; return function() &#123; context = this; args = arguments; timestamp = _.now(); // 第一次调用该方法时，且immediate为true，则调用func函数 var callNow = immediate &amp;&amp; !timeout; // 在wait指定的时间间隔内首次调用该方法，则启动计时器定时调用func函数 if (!timeout) timeout = setTimeout(later, wait); if (callNow) &#123; result = func.apply(context, args); context = args = null; &#125; return result; &#125;; &#125;; 个人实现 功能和underscore实现一样， 去除了underscore的依赖 1234567891011121314151617181920212223242526272829303132333435363738394041 /** * 包裹函数 一段时间间隔只执行函数一次 * @param funcRef 函数引用 * @param wait default, 300ms * 是否立即触发，触发后wait时间内不触发该方法，wait时间后才可以重新触发 * false：wait后触发 没有返回值 * true: wait前触发, 可以有返回值 * @param immediate default false * return : 返回新的函数，使用：将需要调用funcRef的地方，替换为调用新返回的函数即可 */function debounce(funcRef, wait, immediate) &#123; var context, args, timestamp, timeout; wait = wait || 300; return function () &#123; context = this; args = arguments; timestamp = new Date().getTime(); var nowCall = immediate &amp;&amp; !timeout; if(!timeout)&#123; timeout = setTimeout(later, wait) &#125; if(nowCall)&#123; var result = funcRef.apply(context, arguments); context = args = null; return result; &#125; &#125;; function later() &#123; // 当wait指定的时间间隔期间多次调用_.debounce返回的函数，则会不断更新timestamp的值，导致last &lt; wait &amp;&amp; last &gt;= 0一直为true，从而不断启动新的计时器延时执行func var last = new Date().getTime() - timestamp; if (last &lt; wait &amp;&amp; last &gt;= 0) &#123; timeout = setTimeout(later, wait - last); &#125;else &#123; timeout = null; if (!immediate) &#123; funcRef.apply(context, args); if (!timeout) context = args = null; &#125; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[angular中$filter过滤器的使用]]></title>
      <url>%2F2017%2F02%2F18%2Fangular%E4%B8%AD-filter%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[系统提供过滤器currency（货币处理）1&#123;&#123;num | currency : '￥'&#125;&#125; //默认为 '$' date（日期格式化）更详细配置参见这里123456&#123;&#123; today | date:'yyyy-MM-dd' &#125;&#125; //2015-01-01# y M d h m s E 分别表示 年 月 日 时 分 秒 星期# 年月日：(&#123;&#123; today | date:'yyyy-MM-dd' &#125;&#125;) 2015-10-19# 时分秒：(&#123;&#123; today | date:'HH:mm:ss.sss' &#125;&#125;) 10:02:15.701# 英文星期：(&#123;&#123; today | date:'EEEE' &#125;&#125;)Monday# 英文星期简写：(&#123;&#123; today | date:'EEE' &#125;&#125;)Mon filter（匹配字串）123456789101112$scope.childrenArray = [ &#123;name:'kimi',age:3&#125;, &#123;name:'cindy',age:4&#125;, &#123;name:'anglar',age:4&#125;, &#123;name:'shitou',age:6&#125;, &#123;name:'tiantian',age:5&#125; ];$scope.func = function(e)&#123;return e.age&gt;4;&#125;&#123;&#123; childrenArray | filter : 'a' &#125;&#125; //匹配属性值中含有a的&#123;&#123; childrenArray | filter : 4 &#125;&#125; //匹配属性值中含有4的&#123;&#123; childrenArray | filter : &#123;name : 'i'&#125; &#125;&#125; //参数是对象，匹配name属性中含有i的&#123;&#123;childrenArray | filter : func &#125;&#125; //参数是函数，指定返回age&gt;4的 json（对象格式化成json字符串）1&#123;&#123; jsonTest | json&#125;&#125; //没有参数。这东西有什么用呢，我一般也不会在页面上输出一个json串啊，官网说它可以用来进行调试，嗯，是个不错的选择。 limitTo（限制数组长度或者字符串长度）12#有点鸡肋，首先只能从数组或字符串的开头进行截取，其次，js原生的函数就可以代替它了&#123;&#123; childrenArray | limitTo : 2 &#125;&#125; //将会显示数组中的前两项 lowercase（小写）uppercase（大写）number（格式化数字）12345678//在html中用法&#123;&#123; number_expression | number : fractionSize&#125;&#125;//在js中用法$filter('number')(number, fractionSize)//参数//number 待精确的数字//factionSize(可选) 小数点后精确位数，默认值是3.#(默认情况下保留的小数位数小于等于3. 比如: 1234--&gt;1234；1234.56789--&gt;1234.568；1234.56--&gt;1234.56 ) orderBy （排序） 自定义过滤器123456789101112131415//定义filters modulevar filters = angular.module('filters', []); filters.filter('stringAdd',function()&#123; return function (obj, addString) &#123; return obj + addString; &#125;&#125;);//html中使用&#123;&#123; '07' | stringAdd:':00' &#125;&#125; // 07:00// js中使用# 注入$filter$filter('stringAdd')('07', ':00'); // 07:00// 过滤器有对个参数用 ：隔开// &#123;&#123; yourExpression | yourFilter: arg1:arg2:... &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis的安装和配置]]></title>
      <url>%2F2017%2F02%2F18%2Fredis%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[【参考】 安装Redis123456789101112131415161718# 希望将redis安装到此目录 /usr/local/redis# 希望将安装包下载到此目录 /usr/local/src那么安装过程指令如下： $ mkdir /usr/local/redis $ cd /usr/local/src $ wget http://download.redis.io/releases/redis-3.0.7.tar.gz$ tar xzf redis-3.0.7.tar.gz$ cd redis-3.0.7$ make PREFIX=/usr/local/redis install #安装到指定目录中#如果make失败，一般是你们系统中还未安装gcc,那么可以通过yum安装： $ yum install gcc#在安装redis成功后，你将可以在/usr/local/redis看到一个bin的目录，里面包括了以下文件： redis-benchmark redis-check-aof redis-check-dump redis-cli redis-server 将Redis做成服务redis默认运行脚本 ps: /etc/init.d/目录下的脚本就类似与windows中的注册表，在系统启动的时候某些指定脚本将被执行 按以上步骤安装Redi时，其服务脚本位于：/usr/local/src/redis-3.0.7/utils/redis_init_script 拷贝脚本到/etc/init.d/目录下，并命名为redis1$ [sudo] cp /usr/local/src/redis-3.0.7/utils/redis_init_script /etc/init.d/redis 对启动脚本进行修改打开redis脚本文件，并进行编辑123456789$ vim /etc/init.d/redis#修改到正确的路径#EXEC=/usr/local/bin/redis-serverEXEC=/usr/local/redis/bin/redis-server#CLIEXEC=/usr/local/bin/redis-cliCLIEXEC=/usr/local/redis/bin/redis-cli# 设置配置文件路径#CONF="/etc/redis/$&#123;REDISPORT&#125;.conf" 配置Redis启动信息在上面shell脚本指定的配置目录中创建文件，并进行编辑。更详细配置参考这里1234567891011121314151617181920212223242526272829303132$ [sudo] mkdir /etc/redis/$ [sudo] vim /etc/redis/6379.conf写入配置:#!/bin/sh# 是否以后台进程运行，默认为nodaemonize yes# 如以后台进程运行，则需指定一个pid，默认为/var/run/redis.pidpidfile /var/run/redis.pid# 监听端口，默认为6379port 6379#绑定主机IP，默认值为127.0.0.1（注释）bind 127.0.0.1# 超时时间，默认为300（秒）timeout 300# 日志记录等级，有4个可选值，debug，verbose（默认值），notice，warningloglevel verbose#可用数据库数，默认值为16，默认数据库为0databases 16#指出在多长时间内，有多少次更新操作，就将数据同步到数据文件。这个可以多个条件配合，比如默认配置文件中的设置，就设置了三个条件。# 900秒（15分钟）内至少有1个key被改变save 900 1# 300秒（5分钟）内至少有10个key被改变save 300 10# 存储至本地数据库时是否压缩数据，默认为yesrdbcompression yes# 本地数据库文件名，默认值为dump.rdbdbfilename dump.rdb# 本地数据库存放路径，默认值为 ./dir /usr/apps/redis_db#开启之后，redis将在每100毫秒时使用1毫秒的CPU时间来对redis的hash表进行重新hash，可以降低内存的使用。当你的使 用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存activerehashing yes 启动redis服务手动启动命令1$ service redis start 方便redis客户端的使用，可以将Redis的所在目录添加到系统参数PATH中 修改profile文件：/etc/profile 最文件最后一行添加export PATH=&quot;$PATH:/usr/local/redis/bin&quot; 应用配置执行12345678910$ . /etc/profile ``` * 至此可以直径调用redis-cli的命令了```bash$ redis-cli redis 127.0.0.1:6379&gt; auth superman OK redis 127.0.0.1:6379&gt; ping PONG redis 127.0.0.1:6379&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[内置Promise的使用]]></title>
      <url>%2F2017%2F02%2F18%2F%E5%86%85%E7%BD%AEPromise%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[引入方法高版本node已经内嵌了Promise机制 1var Promise = require('promise'); 简单使用 new Promise依赖关系顺序执行12345678910111213141516function testPromise(begin) &#123; return new Promise(function (resolve, reject) &#123; // 在这里写异步方法, resolve是then的第一个参数, reject是then的第二个参数 if (begin &lt;= 3)&#123; resolve(begin); &#125; reject('begin 不允许 &gt; 3'); &#125;).then(function (begin) &#123; console.log(begin); &#125;, function(err)&#123; console.log(err); &#125;);&#125;// 调用测试testPromise(0); // 0testPromise(4); // begin 不允许 &gt; 3 高级使用 new Promise.all非依赖同时执行123456789101112131415161718function onePromise(begin) &#123; return new Promise(function (resolve, reject) &#123; if (begin &lt;= 3)&#123; resolve(begin); &#125; reject('begin = '+ begin +' 不允许 &gt; 3'); &#125;);&#125;function testPromise2(begin)&#123; return new Promise.all([onePromise(begin), onePromise(begin+1), onePromise(begin+2)]).then(function(datas)&#123; console.log(datas); &#125;, function(err)&#123; console.log(err); &#125;)&#125;// 调用测试testPromise2(1); // [ 1, 2, 3 ]testPromise2(2); // begin = 4 不允许 &gt; 3 其他Promise 第三方库 如果node版本较低,可以使用其他实现Promise标准的库 bluebird github Q github Deferredgithub thengithub whengithub asyncgithub eventproxy(事件驱动)github]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[flex布局资料]]></title>
      <url>%2F2017%2F02%2F18%2Fflex%E5%B8%83%E5%B1%80%E8%B5%84%E6%96%99%2F</url>
      <content type="text"><![CDATA[Flex 布局教程：语法篇 http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool flexFlex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。 123.box&#123; display: inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 flex属性容器的属性 flex-direction row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap：wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-contentjustify-content属性定义了项目在主轴上的对齐方式。123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-itemsalign-items属性定义项目在交叉轴上如何对齐。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-contentalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性orderorder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.item &#123; order: &lt;integer&gt;;&#125; flex-growflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrinkflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 flex-basisflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flexflex属性是flex-grow,flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[node的http模块]]></title>
      <url>%2F2017%2F02%2F18%2Fnode%E7%9A%84http%E6%A8%A1%E5%9D%97%2F</url>
      <content type="text"><![CDATA[创建简单服务器参考123456var http = require(&apos;http&apos;);http.createServer(function (request, response) &#123; response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;); response.end(&apos;Hello World\n&apos;);&#125;).listen(1337, &apos;127.0.0.1&apos;);console.log(&apos;Server running at http://127.0.0.1:1337/&apos;); 根据url下载文件123456789101112131415161718var http = require('http');var fs = require('fs');var url = 'http://www.baidu.com/dd2.jpg';var downloadFilePath = '/c/abc.png';var file = fs.createWriteStream(downloadFilePath, &#123;flags: 'w'&#125;);var req = http.get(url, function (res) &#123; res.pipe(file, &#123;end: 'false'&#125;); res.on('end', function () &#123; file.end(); console.log('download success'); &#125;).on('error', function(e) &#123; console.log('error:', e); &#125;);&#125;);req.on('error', function(err)&#123; //错误处理，处理res无法处理到的错误 console.error('download file error out:', url);&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[软件注册码]]></title>
      <url>%2F2017%2F02%2F18%2F%E8%BD%AF%E4%BB%B6%E6%B3%A8%E5%86%8C%E7%A0%81%2F</url>
      <content type="text"><![CDATA[sublime312345678910111213—– BEGIN LICENSE —–Michael BarnesSingle User LicenseEA7E-8213858A353C41 872A0D5C DF9B2950 AFF6F667C458EA6D 8EA3C286 98D1D650 131A97ABAA919AEC EF20E143 B361B1E7 4C8B7F04B085E65E 2F5F5360 8489D422 FB8FC1AA93F6323C FD7F7544 3F39C318 D95E6480FCCC7561 8A4A1741 68FA4223 ADCEDE07200C25BE DBBC4855 C4CFB774 C5EC138C0FEC1CEF D9DCECEC D3A5DAD1 01316C36—— END LICENSE —— 12345678910111213—– BEGIN LICENSE —–Alexey PlutalovSingle User LicenseEA7E-8607763DC19CC1 134CDF23 504DC871 2DE5CE55585DC8A6 253BB0D9 637C87A2 D8D0BA85AAE574AD BA7D6DA9 2B9773F2 324C5DEF17830A4E FBCF9D1D 182406E9 F883EA87E585BBA1 2538C270 E2E857C2 194283CA7234FF9E D0392F93 1D16E021 F191491763909E12 203C0169 3F08FFC8 86D06EA873DDAEF0 AC559F30 A6A67947 B60104C6—— END LICENSE —— webstormlicense server1http://idea.imsxm.com/ or1http://xidea.online]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[事件对象（event）]]></title>
      <url>%2F2017%2F02%2F18%2F%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%EF%BC%88event%EF%BC%89%2F</url>
      <content type="text"><![CDATA[onabort 图像加载被中断 onblur 元素失去焦点 onchange 用户改变域的内容 onclick 鼠标点击某个对象 ondblclick 鼠标双击某个对象 onerror 当加载文档或图像时发生某个错误 onfocus 元素获得焦点 onkeydown 某个键盘的键被按下 onkeypress 某个键盘的键被按下或按住 onkeyup 某个键盘的键被松开 onload 某个页面或图像被完成加载 onmousedown 某个鼠标按键被按下 onmousemove 鼠标被移动 onmouseout 鼠标从某元素移开 onmouseover 鼠标被移到某元素之上 onmouseup 某个鼠标按键被松开 onreset 重置按钮被点击 onresize 窗口或框架被调整尺寸 onselect 文本被选定 onsubmit 提交按钮被点击 onunload 用户退出页面 event对象有哪些属性或者方法 type：事件类型。用来描述这个事件是什么类型的，比如onclick的事件类型为click。 srcElement/target：事件源，就是发生事件的元素； FF下是target，IE下是srcElement cancelBubble：一个布尔属性，把它设置为true的时候，将停止事件进一步起泡到包容层次的元素；(e.cancelBubble = true; 相当于 e.stopPropagation();) 。FF下是后者。 keyCode: 这个不陌生了吧。也非常的常用，用来判断你按下了哪个键 attachEvent(), detachEvent()/addEventListener(), removeEventListener：为指定DOM对象事件类型注册多个事件处理函数的方法，它们有两个参数，第一个是事件类型，第二个是事件处理函数。在 attachEvent()事件执行的时候，this关键字指向的是window对象，而不是发生事件的那个元素； 当然还有其他的一些属性，我这里列出来的都是最常用的。比如还有:button、 clientX,clientY、offsetX,offsetY layerX,layerY、x,y pageX,pageY、altKey,ctrlKey,shiftKey、fromElement,toElement、screenX、screenY。 Event altKey、ctrlKey、shiftKey属性 event.altKey 功能：检测事件发生时Alt键是否被按住了。 语法：event.altKey 取值：true | false 说明：altKey属性为true表示事件发生时Alt键被按下并保持，为false则Alt键没有按下。 altKey属性可结合鼠标或键盘使用，多用于制作一些快捷操作方式。 event.ctrlKey 功能：检测事件发生时Ctrl键是否被按住了。 语法：event.ctrlKey 取值：true | false 说明： ctrlKey属性为true表示事件发生时Ctrl键被按下并保持，为false则Ctrl键没有按下。 ctrlKey属性可结合鼠标或键盘使用，多用于制作一些快捷操作方式。 event.shiftKey 功能：检测事件发生时Shift键是否被按住了。 语法：event.shiftKey 取值：true | false 说明： shiftKey属性为true表示事件发生时Shift键被按下并保持，为false则Shift键没有按下。 shiftKey属性可结合鼠标或键盘使用，多用于制作一些快捷操作方式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[pm2部署服务器]]></title>
      <url>%2F2017%2F02%2F18%2Fpm2%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
      <content type="text"><![CDATA[基本使用 本地和服务器安装pm2 1$ npm install -g pm2 使用pm2启动应用 1$ pm2 start xxx.js 开发中启动，代码变更后自动重启应用 1$ pm2 start xxx.js --watch cluster模式默认情况下pm2是以fork模式启动应用的，如果以cluster模式启动的话，则可以使用pm2自带的负载均衡、零间断重启等功能。1$ pm2 start xxx.js -i 4 上面的命令会以cluster模式启动4个应用进程，并自动为它们提供负载均衡，并且可以使用gracefulReload达到更新应用时不中断服务的效果。 升级pm212$ npm install -g pm2@latest$ pm2 updatePM2 部署接下来需要建立一个部署的配置文件，这个文件在本机（操作发布的机器）和服务器上都需要有，因此最好放入Git版本管理中，并且推送到远程代码库（Git服务器）。 切换到项目目录下，然后执行1$ pm2 ecosystem 即可得到一个示例json文件123456789101112131415161718192021222324252627282930313233343536&#123;&quot;apps&quot; : [&#123; &quot;name&quot; : &quot;API&quot;, &quot;script&quot; : &quot;app.js&quot;, &quot;env&quot;: &#123; &quot;COMMON_VARIABLE&quot;: &quot;true&quot; &#125;, &quot;env_production&quot; : &#123; &quot;NODE_ENV&quot;: &quot;production&quot; &#125;&#125;,&#123; //没有这个环境可以删除掉 &quot;name&quot; : &quot;WEB&quot;, &quot;script&quot; : &quot;web.js&quot;&#125;],&quot;deploy&quot; : &#123; &quot;production&quot; : &#123; &quot;user&quot; : &quot;node&quot;,//登录账号 &quot;host&quot; : &quot;212.83.163.1&quot;,//服务器地址 &quot;ref&quot; : &quot;origin/master&quot;,//git 分支 &quot;repo&quot; : &quot;git@github.com:wuyuedefeng/node-china.club.git&quot;,//git地址 &quot;path&quot; : &quot;/var/www/production&quot;,//服务器项目目录 &quot;post-deploy&quot; : &quot;pm2 startOrRestart ecosystem.json5 --env production&quot; &#125;, &quot;dev&quot; : &#123; &quot;user&quot; : &quot;node&quot;, &quot;host&quot; : &quot;212.83.163.1&quot;, &quot;ref&quot; : &quot;origin/master&quot;, &quot;repo&quot; : &quot;git@github.com:repo.git&quot;, &quot;path&quot; : &quot;/var/www/development&quot;, &quot;post-deploy&quot; : &quot;pm2 startOrRestart ecosystem.json5 --env dev&quot;, &quot;env&quot; : &#123; &quot;NODE_ENV&quot;: &quot;dev&quot; &#125; &#125;&#125;&#125; apps.name和apps.script应该与PM2识别应用有关，后续执行pm2 restart的时候可以对应到进程（未证实） deploy中可以含有多个环境，需要能够通过SSH（公钥认证）登录服务器 web目录并不是真正的放版本库文件的目录，PM2会再建立一个source子目录，这个才是真正放代码的目录 post-deploy是指代码部署完之后执行的命令，这里以Node.js为例子，执行依赖安装，然后重启PM2中的进程 然后就可以使用了 首先需要安装一下1$ pm2 deploy ecosystem.json production setup 如果已经安装可以运行下面这个命令进行部署(需要添加服务器的ssh key到github上)1$ pm2 deploy ecosystem.json production 大功告成！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[服务器环境安装nginx： Ubuntu14.04]]></title>
      <url>%2F2017%2F02%2F17%2F%E5%AE%89%E8%A3%85-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%EF%BC%9A-Ubuntu14-04%2F</url>
      <content type="text"><![CDATA[安装服务器环境： Ubuntu14.04 apt-get 安装12$ [sudo] apt-get update $ [sudo] apt-get install nginx 配置文件： (配置文件所在目录：/etc/ngnix/sites-enabled/)12$ cd /etc/nginx/nginx.conf$ vim nodeChinaClub.conf 写入：12345678910server &#123; server_name itrydo.com; location / &#123; proxy_pass http://localhost:8088; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_set_header Host $host; &#125;&#125; 使配置生效：1service nginx reload]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用vue-cli初始化vue项目]]></title>
      <url>%2F2017%2F02%2F17%2F%E4%BD%BF%E7%94%A8vue-cli%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[init1234$ npm install -g vue-cli$ vue init webpack demo$ cd demo$ npm install demo 是这个示例项目的名字 现在看到目录结构如下 build 目录是一些webpack的文件，配置参数什么的，一般不用动 src 源码文件夹，基本上文件都应该放在这里。 static 生成好的文件会放在这个目录下。 test 测试文件夹，测试都写在这里 .babelrc babel编译参数，vue开发需要babel编译 .editorconfig 看名字是编辑器配置文件，不晓得是哪款编辑器，没有使用过。 .eslintrc.js eslint配置文件，用以规范团队开发编码规范，大中型项目很有用 .gitignore 用来过滤一些版本控制的文件，比如node_modules文件夹 index.html 主页 package.json 项目文件，记载着一些命令和依赖还有简要的项目描述信息 README.md 介绍自己这个项目的，想怎么写怎么写。 添加支持 sass 安装依赖包 12npm install node-sass --save-devnpm install sass-loader --save-dev style中添加lang=&quot;scss&quot; 123// 添加scoped用来生成唯一样式 指定内部样式只对当前组件生效, 不添加scoped样式将作用于全局&lt;style lang=&quot;scss&quot; scoped&gt; &lt;/style&gt; 使用 vue-router 实现单页路由12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;Vue.use(Router)const router = new Router(&#123; routes: [ &#123; path: &apos;/login&apos;, name: &apos;login&apos;, meta: &#123; Auth: false &#125;, component: function (resolve) &#123; require([&apos;views/profiles/Login.vue&apos;], resolve) &#125;, beforeEnter: (to, from, next) =&gt; &#123; next(); &#125; &#125;, &#123; path: &apos;/&apos;, name: &apos;main&apos;, meta: &#123; Auth: true &#125;, component: function (resolve) &#123; require([&apos;components/Main&apos;], resolve) &#125;, children: [ &#123; path: &apos;&apos;, name: &apos;index&apos;, component: function (resolve) &#123; require([&apos;views/Index&apos;], resolve) &#125; &#125;, // 用户管理 &#123; // 以 / 开头的嵌套路径会被当作根路径 path: &apos;/users&apos;, name: &apos;users&apos;, component: function (resolve) &#123; require([&apos;views/users&apos;], resolve) &#125; &#125;, &#123; path: &apos;/users/:userId/edit&apos;, name: &apos;userEdit&apos;, component: function (resolve) &#123; require([&apos;views/users/userEdit&apos;], resolve) &#125; &#125; ] &#125;, &#123; path: &apos;*&apos;, redirect: &apos;/&apos; &#125;, ]&#125;);router.beforeEach((to, from, next) =&gt; &#123; if (to.matched.some(record =&gt; record.meta.Auth) /* &amp;&amp; is not login */) &#123; next(&#123; path: &apos;/login&apos;, query: &#123;redirect: to.fullPath&#125; &#125;) &#125; else&#123; next(); &#125;&#125;)export default router; 文件: 按需加载 用 vuex 管理我们的数据流12345678910111213141516171819// 导入vueximport Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)//导入modulesimport users from &apos;./modules/users&apos;var store = new Vuex.Store(&#123; state: &#123; &#125;, actions: &#123; &#125;, mutations: &#123; &#125;, modules: &#123; users &#125;&#125;) 集成axios到项目中创建http.js12345678910111213141516171819202122232425262728293031323334353637383940414243import axios from 'axios'var store = null;const instance = axios.create();instance.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';// Add a request interceptorinstance.interceptors.request.use(function (config) &#123; // Do something before request is sent return config;&#125;, function (error) &#123; // Do something with request error return Promise.reject(error);&#125;);// Add a response interceptorinstance.interceptors.response.use(function (response) &#123; // Do something with response data if(response.data.code != 10000)&#123; var error = new Error(response.data &amp;&amp; response.data.msg); // alert(error); if(response.data.code == '50007' || response.data.code == '50004')&#123; // store &amp;&amp; store.commit('logout'); &#125; throw error; &#125; return response;&#125;, function (error) &#123; // Do something with response error // alert(error); return Promise.reject(error);&#125;);instance.install = function (Vue, options) &#123; if(options.store) &#123; store = options.store &#125; Vue.prototype.$http = instance; Vue.$http = instance;&#125;;export default instance; usage: eg: in main.js123import $http from &apos;./api/http&apos;Vue.use($http, &#123;store&#125;); then you can use in components1this.$http.get() //equal call axios instanse get or in vuex1Vue.$http.get() 细节，编写自定义插件 请自行参考官方文档 main.js12345678910111213141516import Vue from &apos;vue&apos;import App from &apos;./App&apos;import router from &apos;./router&apos;import store from &apos;./vuex/store&apos;import $http from &apos;./http&apos;Vue.use($http, &#123;store&#125;);/* eslint-disable no-new */new Vue(&#123; el: &apos;#app&apos;, router, store, template: &apos;&lt;App/&gt;&apos;, components: &#123; App &#125;&#125;) 问题列表 vue-cli build后 Webfonts字体路径引用出错的问题找到 webpack.base.conf.js替换 12345678&#123; test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/, loader: &apos;url-loader&apos;, query: &#123; limit: 10000, name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;) &#125;&#125; 替换为 1234&#123; test: /\.(woff|woff2|eot|ttf|svg)(\?.*$|$)/, loader: &apos;url-loader?importLoaders=1&amp;limit=100000&apos;&#125; 解决方法参考自 github]]></content>
    </entry>

    
  
  
</search>
