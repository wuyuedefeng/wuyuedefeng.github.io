<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue axios请求前请求用户信息]]></title>
    <url>%2F2019%2F02%2F28%2Faxios%E8%AF%B7%E6%B1%82%E5%89%8D%E8%AF%B7%E6%B1%82%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839const cusAxios = axios.create(&#123; baseURL: process.env.API_HOST, timeout: 15000&#125;)// cusAxios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;;// Add a request interceptorlet userInfoPromise = nullcusAxios.interceptors.request.use((config) =&gt; &#123; console.log(&apos;begin api:&apos;, config.url) return new Promise((resolve) =&gt; &#123; let accessToken = store.getters[&apos;user/accessToken&apos;] getUserInfo().then(userInfo =&gt; &#123; console.log(&apos;userInfo&apos;, userInfo) if (accessToken) &#123; config.headers.Authorization = `Bearer $&#123;accessToken&#125;` &#125; loadingBar.start() console.log(&apos;after get userInfo api:&apos;, config.url) resolve(config) &#125;) &#125;)&#125;, function (error) &#123; // Do something with request error loadingBar.close() return Promise.reject(error)&#125;)function getUserInfo () &#123; if (!userInfoPromise) &#123; console.log(&apos;begin get userInfo&apos;) userInfoPromise = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;request get userInfo finished&apos;) resolve(&#123;aaa: 111&#125;) &#125;, 5000) &#125;) &#125; return userInfoPromise.then(info =&gt; info)&#125; 测试： 12345678910[HMR] Waiting for update signal from WDS...api.js?93af:16 begin api: /api/web/um/user/queryUserapi.js?93af:38 begin get userInfoNavMain.vue?d842:38 &#123;name: &quot;ManageAlumni&quot;, meta: &#123;…&#125;, path: &quot;/PersonalOrganization/manageAlumni&quot;, hash: &quot;&quot;, query: &#123;…&#125;, …&#125;api.js?93af:16 begin api: /api/web/um/student/queryPageapi.js?93af:41 request get userInfo finishedapi.js?93af:21 userInfo &#123;aaa: 111&#125;api.js?93af:26 after get userInfo api: /api/web/um/user/queryUserapi.js?93af:21 userInfo &#123;aaa: 111&#125;api.js?93af:26 after get userInfo api: /api/web/um/student/queryPage]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue 页面过渡动画]]></title>
    <url>%2F2018%2F05%2F16%2FVue-%E9%A1%B5%E9%9D%A2%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;template&gt; &lt;div id="app"&gt; &lt;transition name="page-toggle-transition"&gt; &lt;router-view class="page-toggle-transition"/&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'App'&#125;&lt;/script&gt;&lt;style lang="scss"&gt; #app &#123; .page &#123; position: absolute; left: 0; right: 0; top: 0; bottom: 0; &amp;.page-top-transition &#123; transition: opacity .3s ease; &amp;.page-top-transition-enter, &amp;.page-top-transition-leave-to &#123; opacity: 0; &#125; &#125; &amp;.page-push-transition &#123; transition: transform .3s ease, opacity .3s ease; &amp;.page-push-transition-enter &#123; transform: translateX(100%); &#125; &amp;.page-push-transition-leave-to &#123; opacity: 0; &#125; &#125; &amp;.page-pop-transition &#123; transition: transform .3s ease, opacity .3s ease; &amp;.page-pop-transition-enter &#123; opacity: 0; &#125; &amp;.page-pop-transition-leave-to &#123; transform: translateX(100%); &#125; &#125; &amp;.page-toggle-transition &#123; transition: transform .3s ease, opacity .3s ease; &amp;.page-toggle-transition-enter &#123; transform: translateX(100%); &#125; &amp;.page-toggle-transition-leave-to &#123; transform: translateX(100%); opacity: 0; &#125; &#125; &#125; &#125;&lt;/style&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[迁移文件修改mysql utf8编码到utf8mb4]]></title>
    <url>%2F2018%2F03%2F14%2F%E8%BF%81%E7%A7%BB%E6%96%87%E4%BB%B6utf8-%E8%BD%AC-utf8mb4%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930class ConvertUtf8ToUtf8mb4 &lt; ActiveRecord::Migration[5.0] def db ActiveRecord::Base.connection end def up execute &quot;ALTER DATABASE `#&#123;db.current_database&#125;` CHARACTER SET utf8mb4;&quot; db.tables.each do |table| next if %w(ar_internal_metadata schema_migrations).include?(table) next if db.views.include?(table) # Skip views. This will not be necessary in Rails 5.1, when `db.tables` will change to only return actual tables. execute &quot;ALTER TABLE `#&#123;table&#125;` CHARACTER SET = utf8mb4;&quot; db.columns(table).each do |column| case column.sql_type when /([a-z]*)text/i execute &quot;ALTER TABLE `#&#123;table&#125;` CHANGE `#&#123;column.name&#125;` `#&#123;column.name&#125;` #&#123;$1.upcase&#125;TEXT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;&quot; when /((?:var)?char)\(([0-9]+)\)/i # InnoDB has a maximum index length of 767 bytes, so for utf8 or utf8mb4 # columns, you can index a maximum of 255 or 191 characters, respectively. # If you currently have utf8 columns with indexes longer than 191 characters, # you will need to index a smaller number of characters. indexed_column = db.indexes(table).any? &#123; |index| index.columns.include?(column.name) &#125; sql_type = (indexed_column &amp;&amp; $2.to_i &gt; 191) ? &quot;#&#123;$1&#125;(191)&quot; : column.sql_type.upcase default = (column.default.nil?) ? &apos;&apos; : &quot;DEFAULT &apos;#&#123;column.default&#125;&apos;&quot; null = (column.null) ? &apos;&apos; : &apos;NOT NULL&apos; execute &quot;ALTER TABLE `#&#123;table&#125;` CHANGE `#&#123;column.name&#125;` `#&#123;column.name&#125;` #&#123;sql_type&#125; CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci #&#123;default&#125; #&#123;null&#125;;&quot; end end endend]]></content>
  </entry>
  <entry>
    <title><![CDATA[rails sql语句 时间分段查询，按时间段分组，分时间段统计]]></title>
    <url>%2F2018%2F02%2F23%2Frails-sql%E8%AF%AD%E5%8F%A5-%E6%97%B6%E9%97%B4%E5%88%86%E6%AE%B5%E6%9F%A5%E8%AF%A2%EF%BC%8C%E6%8C%89%E6%97%B6%E9%97%B4%E6%AE%B5%E5%88%86%E7%BB%84%EF%BC%8C%E5%88%86%E6%97%B6%E9%97%B4%E6%AE%B5%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[12#按小时分组select DATE_FORMAT(created_at,&apos;%H&apos;) hours,count(id) count from doctors group by DATE_FORMAT(created_at,&apos;%H&apos;); 时间段字符如下1234567891011121314151617181920212223242526%a - The abbreviated weekday name (&apos;&apos;Sun&apos;&apos;)%A - The full weekday name (&apos;&apos;Sunday&apos;&apos;)%b - The abbreviated month name (&apos;&apos;Jan&apos;&apos;)%B - The full month name (&apos;&apos;January&apos;&apos;)%c - The preferred local date and time representation%d - Day of the month (01..31)%H - Hour of the day, 24-hour clock (00..23)%I - Hour of the day, 12-hour clock (01..12)%j - Day of the year (001..366)%m - Month of the year (01..12)%M - Minute of the hour (00..59)%p - Meridian indicator (&apos;&apos;AM&apos;&apos; or &apos;&apos;PM&apos;&apos;)%S - Second of the minute (00..60)%U - Week number of the current year, starting with the first Sunday as the first day of the first week (00..53)%W -Week number of the current year, starting with the first Monday as the first day of the first week (00..53) 该句有错误， 滚动下方参考w3c 一年的第几周，以星期一作为一周的开始计算应该是：%u%w - Day of the week (Sunday is 0, 0..6)%x - Preferred representation for the date alone, no time%X - Preferred representation for the time alone, no date%y - Year without a century (00..99)%Y - Year with century%Z - Time zone name%% - Literal &apos;&apos;%&apos;&apos; character 使用实例 1234567doctor_chart_new = AgentOrder.find_by_sql("select DATE_FORMAT(table_a.order_time,'%d') df, count(table_a.id) count from(SELECT * FROM agent_ordersGROUP BY agent_orders.doctor_idORDER BY agent_orders.doctor_id asc) as table_aWHERE (order_time BETWEEN '#&#123;month_beginning&#125;' AND '#&#123;month_end&#125;')GROUP BY DATE_FORMAT(table_a.order_time,'%d')") 12345678910111213141516171819202122232425262728293031323334# w3c 更准确可以使用的格式有：格式 描述%a 缩写星期名%b 缩写月名%c 月，数值%D 带有英文前缀的月中的天%d 月的天，数值(00-31)%e 月的天，数值(0-31)%f 微秒%H 小时 (00-23)%h 小时 (01-12)%I 小时 (01-12)%i 分钟，数值(00-59)%j 年的天 (001-366)%k 小时 (0-23)%l 小时 (1-12)%M 月名%m 月，数值(00-12)%p AM 或 PM%r 时间，12-小时（hh:mm:ss AM 或 PM）%S 秒(00-59)%s 秒(00-59)%T 时间, 24-小时 (hh:mm:ss)%U 周 (00-53) 星期日是一周的第一天%u 周 (00-53) 星期一是一周的第一天%V 周 (01-53) 星期日是一周的第一天，与 %X 使用%v 周 (01-53) 星期一是一周的第一天，与 %x 使用%W 星期名%w 周的天 （0=星期日, 6=星期六）%X 年，其中的星期日是周的第一天，4 位，与 %V 使用%x 年，其中的星期一是周的第一天，4 位，与 %v 使用%Y 年，4 位%y 年，2 位]]></content>
  </entry>
  <entry>
    <title><![CDATA[更新服务器node版本]]></title>
    <url>%2F2018%2F02%2F07%2F%E6%9B%B4%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%99%A8node%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[更新到 Node.js v9.x:1234567# Using Ubuntucurl -sL https://deb.nodesource.com/setup_9.x | sudo -E bash -sudo apt-get install -y nodejs# Using Debian, as rootcurl -sL https://deb.nodesource.com/setup_9.x | bash -apt-get install -y nodejs 更新到 Node.js v8.x:1234567# Using Ubuntucurl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -sudo apt-get install -y nodejs# Using Debian, as rootcurl -sL https://deb.nodesource.com/setup_8.x | bash -apt-get install -y nodejs 更新到 Node.js v7.x:1234567# Using Ubuntucurl -sL https://deb.nodesource.com/setup_7.x | sudo -E bash -sudo apt-get install -y nodejs# Using Debian, as rootcurl -sL https://deb.nodesource.com/setup_7.x | bash -apt-get install -y nodejs]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mysql必备知识]]></title>
    <url>%2F2017%2F12%2F20%2FMysql%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[join table]]></content>
  </entry>
  <entry>
    <title><![CDATA[工具安装]]></title>
    <url>%2F2017%2F12%2F12%2F%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装 brew1$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装 sequel mysql客户端1$ brew cask install sequel-pro 安装 rds redis客户端1$ brew cask install rdm]]></content>
      <tags>
        <tag>install</tag>
        <tag>brew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx配置 【vue、 rails】]]></title>
    <url>%2F2017%2F12%2F09%2Fnginx%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[vue http config12345678910111213141516171819202122server &#123; server_name wap.waimai.com; listen 80; listen [::]:80; root /mnt/www/waimai-wap; index index.html; location ^~ /static/ &#123; gzip_static on; expires max; add_header Cache-Control public; &#125; location / &#123; try_files $uri $uri/ /index.html; &#125; location ~* \.(css|js|gif|jpe?g|png)$ &#123; expires 100d; access_log off; add_header Pragma public; add_header Cache-Control &quot;public&quot;; &#125;&#125; vue https config123456789101112131415161718192021222324server &#123; listen 443; listen 80; ssl on; ssl_certificate /etc/letsencrypt/live/www.itrydo.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/www.itrydo.com/privkey.pem; server_name www.itrydo.com; if ( $http_user_agent ~* &quot;(Android|iPhone|Windows Phone|UC|Kindle)&quot; )&#123; rewrite ^/(.*)$ http://m.itrydo.com$uri redirect; &#125; root /mnt/www/waimai/current/dist/; index index.html; location ^~ /static/ &#123; gzip_static on; expires max; add_header Cache-Control public; &#125; location / &#123; try_files $uri $uri/ /index.html; &#125;&#125; rails config123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869upstream waimai &#123; server unix:///mnt/www/relation_api/shared/tmp/sockets/puma.sock;&#125;# httpserver &#123; listen 80; server_name api.itrydo.com api.waimai.com adm.waimai.com bus.waimai.com; # change to match your URL index index.html; root /mnt/www/relation_api/current/public; # I assume your app is located at that location try_files $uri/index.html $uri @app; location @app &#123; # try_files $uri/index.html $uri =404; proxy_pass http://waimai; # match the name of upstream directive which is defined above proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; location /cable &#123; proxy_pass http://waimai; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;Upgrade&quot;; &#125;&#125;# http redirect https#server &#123;# server_name api.itrydo.com api.waimai.com adm.waimai.com bus.waimai.com;# listen 80; # return 308 https://$server_name$request_uri; # location / &#123; # rewrite ^/(.*)$ https://$server_name/$1 permanent; # &#125;# rewrite ^ https://$server_name$request_uri? permanent;#&#125;# httpsserver &#123; server_name api.itrydo.com api.waimai.com adm.waimai.com bus.waimai.com; listen 443 ssl http2; index index.html; root /mnt/www/relation_api/current/public; ssl on; ssl_certificate /home/deploy/letsencrypt/api/api.chained.crt; ssl_certificate_key /home/deploy/letsencrypt/api/api.waimai.com.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5; ssl_prefer_server_ciphers on; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; try_files $uri/index.html $uri @app; location /cable &#123; proxy_pass http://waimai; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;Upgrade&quot;; &#125; location @app &#123; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_set_header X-Forwarded-Ssl on; proxy_set_header X-Forwarded-Port 443; proxy_set_header X-Forwarded-Host $host; proxy_redirect off; proxy_pass http://waimai; &#125; &#125; 代码段wap访问www,重定向到wap1234server_name www.itrydo.com;if ( $http_user_agent ~* &quot;(Android|iPhone|Windows Phone|UC|Kindle)&quot; )&#123; rewrite ^/(.*)$ http://wap.itrydo.com$uri redirect;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[ubuntu修改时区]]></title>
    <url>%2F2017%2F10%2F18%2Fubuntu%E4%BF%AE%E6%94%B9%E6%97%B6%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[执行下面命令，并按照提示选择“Asia/Shanghai”：1$ sudo dpkg-reconfigure tzdata]]></content>
  </entry>
  <entry>
    <title><![CDATA[https]]></title>
    <url>%2F2017%2F08%2F04%2Fhttps%2F</url>
    <content type="text"><![CDATA[12345$ ssh deploy@IPADDRESS$ cd ~$ git clone https://github.com/letsencrypt/letsencrypt$ cd letsencrypt/$ ./letsencrypt-auto --agree-dev-preview --server https://acme-v01.api.letsencrypt.org/directory auth 123$ cd ~$ mkdir etc$ openssl dhparam -out dhparams.pem 2048 1234567891011121314151617181920212223242526upstream vitamin &#123; server unix:///mnt/www/vitamin/shared/tmp/sockets/puma.sock;&#125;server &#123; listen 443 ssl; server_name xn--n8jhv5b1dva9290n.com; root /mnt/www/vitamin/shared/public; location / &#123; proxy_pass http://vitamin; # match the name of upstream directive which is defined above proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; ssl on; ssl_certificate /etc/letsencrypt/live/xn--n8jhv5b1dva9290n.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/xn--n8jhv5b1dva9290n.com/privkey.pem; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers &apos;ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA&apos;; ssl_prefer_server_ciphers on; ssl_session_cache shared:SSL:10m; ssl_dhparam /home/deploy/etc/dhparams.pem;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[rails ssh login]]></title>
    <url>%2F2017%2F07%2F24%2Frails-ssh-log%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122require &apos;net/ssh&apos;host = &apos;13.19.13.24&apos;username = &apos;deploy&apos;port = 5331#连接服务器，执行 tail -f 指令server_cmd1 = %q(tail -f /mnt/www/nirvana_staging/current/log/production.log)# 连接到远程主机ssh = Net::SSH.start(host, username, &#123; :port =&gt; port &#125;) do |ssh| result = ssh.exec!(server_cmd1) do |ssh, type , data| if /INFO/ =~ data puts &quot;\e[32m#&#123;data&#125;\e[0m&quot; #这里的data就是，每次写入staging.log的数据 elsif /FATAL/ =~ data puts &quot;\e[31m#&#123;data&#125;\e[0m&quot; elsif /WARN/ =~ data puts &quot;\e[33m#&#123;data&#125;\e[0m&quot; else p data end end puts resultend]]></content>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2017%2F07%2F21%2Fcanvas%2F</url>
    <content type="text"><![CDATA[hex to rgb12345678function hexToRgb(hex) &#123; var result = /^#?([a-f\d]&#123;2&#125;)([a-f\d]&#123;2&#125;)([a-f\d]&#123;2&#125;)$/i.exec(hex); return result ? &#123; r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) &#125; : null;&#125; rgb to hex123function rgbToHex(r, g, b) &#123; return &quot;#&quot; + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);&#125; 像素点遍历与修改123456789101112function decryptColor(canvas, rotten) &#123; var ctx = canvas.getContext(&apos;2d&apos;) var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height); var data = imgData.data; for (let i = 0; i &lt; data.length; i+=4) &#123; data[i] = data[i] // r data[i+1] = decNumber(data[i+1], i+1, rotten) // g data[i+2] = decNumber(data[i+2], i+2, rotten) // b &#125; ctx.putImageData(imgData, 0, 0)&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[form表单提交]]></title>
    <url>%2F2017%2F07%2F05%2Fform%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[js form提交文件axis1234const config = &#123; headers: &#123; &apos;Content-Type&apos;: &apos;multipart/form-data&apos; &#125; &#125;;let fd = new FormData();fd.append(&apos;file&apos;,files[0])return axios.post(&quot;http://localhost:5000/upload&quot;, fd, config) 多文件提交1234567const config = &#123; headers: &#123; &apos;Content-Type&apos;: &apos;multipart/form-data&apos; &#125; &#125;;let fd = new FormData();// 这里必须用循环，一个个添加到表单Array.prototype.forEach.call(evt.target.files, file =&gt; &#123; fd.append(&apos;files&apos;, file)&#125;)return axios.post(&quot;http://localhost:5000/upload&quot;, fd, config)]]></content>
  </entry>
  <entry>
    <title><![CDATA[rails gems]]></title>
    <url>%2F2017%2F06%2F14%2Frails-gems%2F</url>
    <content type="text"><![CDATA[Rails的环境变量设置 gem Figaro tree型结构 gem ancestry github ruby-china wiki 搜索条件过滤 gem ransack github ruby-child post ransack enum question resolve 构建积分,等级,徽章 gem merit github 用更优雅的方式构建的网站的积分，等级，徽章系统 用户活跃度 gem activerecord-reputation-system github 状态机 gem aasm 用户活跃度 gem activerecord-reputation-system 更友好的展示错误页 gem better_errors api 表单验证，数据验证 gem reform gem reform validation usage gem dry-validation gem rails_param cors gem rack-cors 配置application.rb1234567# Rails 5 config.middleware.insert_before 0, &apos;Rack::Cors&apos;, debug: false do allow do origins (ENV[&apos;CORS_HOSTS&apos;] ? ENV[&apos;CORS_HOSTS&apos;].split(&apos;,&apos;) : &apos;*&apos;) resource &apos;*&apos;, headers: :any, methods: :any, credentials: false end end 加标签[tag] gem acts-as-taggable-on 权限管理 gem Pundit]]></content>
  </entry>
  <entry>
    <title><![CDATA[css疑难杂症]]></title>
    <url>%2F2017%2F06%2F06%2Fcss%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%2F</url>
    <content type="text"><![CDATA[垂直居中 单行文字居中 line-height123&lt;div style="line-height: 100px"&gt; &lt;span&gt;文字垂直居中&lt;/span&gt;&lt;/div&gt; table-cell, vertical-align123&lt;div style="height: 300px; display: table-cell; vertical-align: middle;"&gt; &lt;p&gt;aaa&lt;/p&gt;&lt;/div&gt; 多行文字居中 table-cell1234&lt;div style="height: 300px; display: table-cell; vertical-align: middle;"&gt; &lt;p&gt;aaa&lt;/p&gt; &lt;p&gt;bbb&lt;/p&gt;&lt;/div&gt; 单行文字和图片垂直居中 (前提：内部字体相对较小) line-height, vertical-align1234&lt;div style="line-height: 500px;"&gt; &lt;img src="./titles-calc.png" style="/*display: inline-block;*/vertical-align: middle;"&gt; &lt;span style="vertical-align: middle"&gt;aaa&lt;/span&gt;&lt;/div&gt; flex 布局1234&lt;div style="height: 500px; display: flex; align-items: center;"&gt; &lt;img src="./titles-calc.png"&gt; &lt;span&gt;aaa&lt;/span&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[加密算法]]></title>
    <url>%2F2017%2F05%2F31%2F%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[javascriptAES crypto-js 下面设置opt为了使每次加密，都会生成相同的密文 1234567891011121314151617181920212223const AESCrypt = require(&apos;crypto-js/aes&apos;)const encUtf8 = require(&apos;crypto-js/enc-utf8&apos;)const modeCFB = require(&apos;crypto-js/mode-cfb&apos;)const NoPadding = require(&apos;crypto-js/pad-nopadding&apos;)const IV = &apos;nirvana&apos;const opt = &#123; iv: encUtf8.parse(IV), mode: modeCFB, padding: NoPadding&#125;let AES = &#123; encrypt: (text, secretkey) =&gt; &#123; let enText = AESCrypt.encrypt(text, encUtf8.parse(secretkey), opt).toString() return atob(enText) &#125;, decrypt: (text, secretKey) =&gt; &#123; let deText = btoa(text) return AESCrypt.decrypt(deText, encUtf8.parse(secretKey), opt).toString(encUtf8) &#125;&#125;export &#123; AES &#125;]]></content>
      <categories>
        <category>加密</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql客户端连接服务器]]></title>
    <url>%2F2017%2F05%2F30%2Fmysql%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[登录服务器 进入数据库 12mysql -h localhost -u root -p Enter password: *** 创建一个新用户mars 1234mysql&gt; use mysql;# 格式：grant 权限 on 数据库名.表名 用户@登录主机 identified by "用户密码";# 如果 grant select,update,insert,delete on 可以设置为 grant all privileges onmysql&gt; grant all privileges on waimaiph_pro.* to 'mars'@'11.11.11.11' identified by "123456" &#39;mars&#39;@&#39;11.11.11.11&#39;：mars用户连接的客户端ip必须是11.11.11.11 如果允许来自所有不同的IP访问： &#39;mars&#39;@&#39;%&#39; 1grant all privileges on waimaiph_pro.* to &apos;mars&apos;@&apos;%&apos; identified by &quot;123456&quot; 将host字段的值改为%就表示在任何客户端机器上能以mars用户登录到mysql服务器，建议在开发时设为%。 1update user set host = &apos;%&apos; where user = &apos;mars&apos;; 1mysql&gt; FLUSH PRIVILEGES; 配置参数MySql 5.71/etc/mysql/mysql.conf.d/mysqld.cnf below versions1/etc/mysql/my.cnf modify to bind-address = 0.0.0.0]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vim常用命令]]></title>
    <url>%2F2017%2F05%2F06%2Fvim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2017%2F05%2F06%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[命令大全 删除git代码管理中已经提交的服务器的提交123#git reset --hard HEAD~1 # 取消当前版本之前的一次提交git reset --hard HEAD~2 # 取消当前版本之前的两次提交git push origin HEAD --force # 强制提交到远程版本库，从而删除之前的两次提交数据 在mac中自动保存git用户名与密码如此简单在Mac OS X中这个操作竟然如此简单。只需在Terminal中输入如下的命令：1git config --global credential.helper osxkeychain 然后在git操作时只要输入一次用户名与密码，以后就不用输入了。 【参考资料】 Git keeps prompting me for password]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js table拖动排序]]></title>
    <url>%2F2017%2F05%2F05%2Fjs-table%E6%8B%96%E5%8A%A8%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[table添加类.draggable-items 将可拖动的tr写到tbody中 添加下面js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var cloneEl = nullvar currentDragEl = nullvar parentNode = document.querySelector(&apos;.draggable-items tbody&apos;)var trs = parentNode.querySelectorAll(&apos;tr&apos;)trs.forEach(function (el, index) &#123; el.setAttribute(&apos;draggable&apos;, true) el.orSeq = index el.index = index el.onmousedown = function (event) &#123; cloneEl = el.cloneNode(true) parentNode.insertBefore(cloneEl, el) cloneEl.index = el.index el.style.display = &apos;none&apos; currentDragEl = el cloneEl.onmouseup = currentDragEl.onmouseup = function (event) &#123; currentDragEl.index = cloneEl.index parentNode.removeChild(currentDragEl) parentNode.insertBefore(currentDragEl, cloneEl) parentNode.removeChild(cloneEl) currentDragEl.style.display = &apos;table-row&apos; &#125; &#125; el.ondragover = function (event) &#123; var nowElIndex = el.index if (el.index &gt; cloneEl.index) &#123; parentNode.removeChild(cloneEl) for (let i = cloneEl.index + 1; i &lt;= el.index; i++) &#123; el.index = el.index - 1 &#125; if (parentNode.lastChild === el) &#123; parentNode.appendChild(cloneEl) &#125; else &#123; parentNode.insertBefore(cloneEl, el.nextSibling) &#125; cloneEl.index = nowElIndex &#125; else if (el.index &lt; cloneEl.index) &#123; for (let i = el.index; i &lt; cloneEl.index; i++) &#123; el.index = el.index + 1 &#125; parentNode.removeChild(cloneEl) parentNode.insertBefore(cloneEl, el) cloneEl.index = nowElIndex &#125; &#125;&#125;)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh]]></title>
    <url>%2F2017%2F04%2F28%2Fssh%2F</url>
    <content type="text"><![CDATA[Generating a new SSH key 生成秘钥 1$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 把公钥文件id_rsa.pub拷贝到需要登录的服务器上 登录远程服务器，在用户根目录下新建.ssh文件夹（如果不存在），在其中新建authorized_keys文件（如果不存在），把id_rsa.pub添加到authorized_keys文件中 退出当前远程登录，之后就可以不使用密码远程登录了]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>install ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux rails 部署 配置基础]]></title>
    <url>%2F2017%2F04%2F26%2Flinux%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[important参考文章 http://thelazylog.com/deploying-rails-application-with-nginx-puma-and-mina/ https://gorails.com/deploy/ubuntu/ http://xufei.logdown.com/posts/2014/03/05/rails-mina-puma-nginx 用户管理查询当前用户信息1234567$ who am i # 伪终端的用户名 伪终端序号(pts/0) 打开时间$ who -a # 打印能打印的全部$ who -d # 打印死掉的进程$ who -m # 同am i,mom likes$ who -q # 打印当前登录用户数及用户名$ who -u # 打印当前登录用户登录信息$ who -r 打印运行等级 创建用户新建一个叫 mars 的用户： 1sudo adduser mars # 默认生成的 用户组 和 用户名 相同 切换用户到mars1su -l mars 用户组查看用户属于哪些用户组1groups mars 将其它用户加入 sudo 用户组12$ su -l mars # 切换登录用户$ sudo ls 会提示 mars 不在 sudoers 文件中，意思就是 mars 不在 sudo 用户组中，至于 sudoers 文件（/etc/sudoers）你现在最好不要动它，操作不慎会导致比较麻烦的后果。 使用 usermod 命令可以为用户添加用户组 -a&lt;追加&gt; 把用户追加到某些组中，仅与-G选项一起使用。 -g&lt;群组&gt; 修改用户所属的群组。 -G&lt;群组&gt; 修改用户所属的附加群组。 usermod -g 这条命令编辑/etc/passwd文件，修改相应用户的组ID usermod -G 这条命令编辑/etc/group文件，增加组成员。 eg: 把mars用户加入sudo组： usermod -aG sudo mars # 多个组之间用空格隔开123$ groups mars$ sudo usermod -G sudo mars$ groups mars 删除用户1sudo deluser mars --remove-home Linux 文件权限变更文件所有者1$ sudo chown [新用户名] [文件名] 修改文件权限1$ chmod 700 iphone6 # 现在，其他用户已经不能读这个“ iphone6 ”文件了 方式二：加减赋值操作 1$ chmod go-rw iphone6 g、o 还有 u 分别表示 group、others 和 user，+ 和 - 分别表示增加和去掉相应的权限。 添加SSH 到服务器1234cd ~mkdir .sshcd .sshvim authorized_keys # 将本机id_rsa.pub中的key粘贴进去 服务器生成ssh key1$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 安装nginxrails ngnix配置 参考112$ [sudo] apt-get update $ [sudo] apt-get install nginx 配置文件： (配置文件所在目录：/etc/ngnix/sites-enabled/)12$ cd /etc/nginx/conf.d$ vim nodeChinaClub.conf 使配置生效：1sudo service nginx reload 123sudo service nginx startsudo service nginx stopsudo service nginx restart vim /etc/nginx/sites-available/wedesign.conf12345678910111213141516171819202122232425262728upstream wedesign &#123; server unix:///mnt/www/wedesign/shared/tmp/sockets/puma.sock;&#125;server &#123; listen 80; server_name rails.itrydo.com; # change to match your URL root /mnt/www/wedesign/shared/public/assets; # I assume your app is located at that location location / &#123; proxy_pass http://wedesign; # match the name of upstream directive which is defined above proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; location ~* ^/assets/ &#123; # Per RFC2616 - 1 year maximum expiry expires 1y; add_header Cache-Control public; # Some browsers still send conditional-GET requests if there&apos;s a # Last-Modified header or an ETag header even if they haven&apos;t # reached the expiry date sent in the Expires header. add_header Last-Modified &quot;&quot;; add_header ETag &quot;&quot;; break; &#125;&#125; creating symlink in /etc/nginx/sites-enabled1sudo ln -sf /etc/nginx/sites-available/wedesign.conf /etc/nginx/sites-enabled/wedesign.conf 启动报错可以执行下面命令，会打印出错误信息（个人测试）1sudo nginx -t -c /etc/nginx/nginx.conf mina123bundle exec puma -e production -b unix:///mnt/www/wedesign/shared/tmp/sockets/puma.sock# 后台启动 -dbundle exec puma -e production -d -b unix:///mnt/www/wedesign/shared/tmp/sockets/puma.sock 安装git1sudo apt-get install git 安装rbenv1sudo apt-get install rbenv ruby-build 手动安装: 参考11234567891011121314git clone https://github.com/rbenv/rbenv.git ~/.rbenvcd ~/.rbenv &amp;&amp; src/configure &amp;&amp; make -C srcecho &apos;export PATH=&quot;$HOME/.rbenv/bin:$PATH&quot;&apos; &gt;&gt; ~/.bashrcecho &apos;eval &quot;$(rbenv init -)&quot;&apos; &gt;&gt; ~/.bashrc~/.rbenv/bin/rbenv initexec $SHELL# 安装ruby-buildgit clone https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build# 通过 gem 命令安装完 gem 后无需手动输入 rbenv rehash 命令, 推荐git clone git://github.com/sstephenson/rbenv-gem-rehash.git ~/.rbenv/plugins/rbenv-gem-rehash# 通过 rbenv update 命令来更新 rbenv 以及所有插件, 推荐git clone git://github.com/rkh/rbenv-update.git ~/.rbenv/plugins/rbenv-update# 使用 Ruby China 的镜像安装 Ruby, 国内用户推荐git clone git://github.com/AndorChen/rbenv-china-mirror.git ~/.rbenv/plugins/rbenv-china-mirror 安装ruby12345sudo apt-get install -y libssl-dev libreadline-dev zlib1g-devrbenv install 2.4.1rbenv versionsrbenv local 2.4.1gem install bundler 安装mysql检查系统中是否已经安装了MySQL1sudo netstat -tap | grep mysql 如果没有安装，则安装MySQL.1sudo apt-get install mysql-server mysql-client libmysqlclient-dev 测试安装是否成功：1sudo netstat -tap | grep mysql 也可通过登录MySQL测试1mysql -uroot -p MySQL的一些简单管理：123456789# 启动MySQL服务： sudo service mysql start # 停止MySQL服务： sudo service mysql stop# 修改 MySQL 的管理员密码： sudo mysqladmin -u root password newpassword# 设置远程访问(正常情况下，mysql占用的3306端口只是在IP 127.0.0.1上监听，拒绝了其他IP的访问（通过netstat可以查看到）。取消本地监听需要修改 my.cnf 文件：)： sudo vi /etc/mysql/my.cnfbind-address = 127.0.0.1 //找到此内容并且注释 MySQL安装后的目录结构分析(此结构只针对于使用apt-get install 在线安装情况)：12345678# 数据库存放目录： /var/lib/mysql/# 相关配置文件存放目录： /usr/share/mysql# 相关命令存放目录： /usr/bin(mysqladmin mysqldump等命令)# 启动脚步存放目录： /etc/rc.d/init.d/ 图形软件12NavicatSequel pro 安装node1sudo apt-get install nodejs mina 和 cap部署的配置方式参考1: cap_and_mina 参考2: Mina + Puma 参考3: 中文项目，英文项目单独部署 mina首次部署可能无法自动创建数据库123cd /mnt/www/wedesign/current# then run rake db:create RAILS_ENV=production 成功部署相关配置/mnt/www/wedesign/shared/config/puma.rb1234567891011121314151617181920#!/usr/bin/env pumaenvironment &quot;production&quot;daemonize trueworkers 2threads 2,16bind &quot;unix:///mnt/www/wedesign/shared/tmp/sockets/puma.sock&quot;pidfile &quot;/mnt/www/wedesign/shared/tmp/pids/puma.pid&quot;state_path &quot;/mnt/www/wedesign/shared/tmp/sockets/puma.state&quot;stdout_redirect &apos;/mnt/www/wedesign/shared/log/stdout&apos;, &apos;/mnt/www/wedesign/shared/log/stderr&apos;directory &quot;/mnt/www/wedesign/current&quot;activate_control_app &apos;unix:///mnt/www/wedesign/shared/tmp/sockets/pumactl.sock&apos;prune_bundler database.yml123456789101112default: &amp;default adapter: mysql2 encoding: utf8 pool: 5 username: root password: host: localhostproduction: &lt;&lt;: *default database: [project_database_name] username: [database_username] password: [database_password] secrets.yml1234production: #secret_key_base: &lt;%= ENV[&quot;SECRET_KEY_BASE&quot;] %&gt; # or run rake secret secret_key_base: [secret_key] /etc/nginx/sites-available/wedesign.conf1234567891011121314151617181920212223242526272829upstream wedesign &#123; server unix:///mnt/www/wedesign/shared/tmp/sockets/puma.sock;&#125;server &#123; listen 80; server_name rails.itrydo.com; # change to match your URL root /mnt/www/wedesign/shared/public; # I assume your app is located at that location location / &#123; proxy_pass http://wedesign; # match the name of upstream directive which is defined above proxy_set_header Host $host; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; location ~* ^/assets/ &#123; # Per RFC2616 - 1 year maximum expiry expires 1y; add_header Cache-Control public; # Some browsers still send conditional-GET requests if there&apos;s a # Last-Modified header or an ETag header even if they haven&apos;t # reached the expiry date sent in the Expires header. add_header Last-Modified &quot;&quot;; add_header ETag &quot;&quot;; break; &#125;&#125; then1$ sudo ln -sf /etc/nginx/sites-available/wedesign.conf /etc/nginx/sites-enabled/wedesign.conf]]></content>
      <categories>
        <category>rails</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue基础]]></title>
    <url>%2F2017%2F03%2F26%2Fvue%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596var vm = new Vue(&#123; el: &apos;body&apos;, data: &#123; a: 1 &#125;, // 计算属性 computed: &#123; b: function()&#123; //默认是get return this.a + 1; &#125;, c: &#123; get: function()&#123; return this.a + 1; &#125; set: function(val)&#123; this.a = val; &#125; &#125; &#125;, // 过滤器@1.x currency capitalize uppercase downcase debounce(ms) limitBy(count, index=0) filterBy(str) orderBy(1/-1) ... fileters: &#123; &#125;, // @1.x transition // 动画过度 可通过类定义，也可使用transitions // &lt;div class=&quot;animated&quot; v-show=&quot;toggle&quot; transition=&quot;bounce&quot;&gt;&lt;/div&gt; // 这里的class animated是animate.css做动画必须类！ transitions: &#123; bounce: &#123; enterClass: &apos;zoomInLeft&apos;, leaveClass: &apos;zoomOutRight&apos; &#125; &#125;, // @2.x transition // .fade-enter&#123;&#125; // 初始状态 // .fade-enter-active&#123;&#125; //变化成的状态-&gt;显示 // .fade-leave&#123;&#125; // .fade-leave-active&#123;&#125; //变化成的状态-&gt;离开(消失) &lt;transition name=&quot;fade&quot; @before-enter=&quot;beforeEnter()&quot; @enter=&quot;enter()&quot; @after-enter=&quot;afterEnter&quot; @before-leave=&quot;beforeLeave&quot; @leave=&quot;leave&quot; @after-leave=&quot;afterLeave&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;/transition&gt; //2.x 结合animate.css使用 &lt;transition enter-active-class=&quot;zoomInLeft&quot; leave-active-class=&quot;bounceOutRight&quot;&gt; &lt;p class=&quot;animated&quot; v-show=&quot;show&quot;&gt;&lt;/p&gt; &lt;/transition created: function()&#123;&#125;, // 创建之后 beforeCompile: function()&#123;&#125;, // 编译之前 @1.x compiled: function()&#123;&#125;, // 变异之后 @1.x ready: function()&#123;&#125;, //节点插入到文档 @1.x beforeDestroy: function()&#123;&#125;, //销毁之前 destroyed: function()&#123;&#125; // 销毁之后&#125;)vm.$el // 元素vm.$data // data本身vm.$mount // 手动挂载Vue程序vm.options // 获取自定义属性对象vm.$destroy // 销毁对象vm.$log() // 查看当前数据状态// 全局自定义过滤器Vue.filter(&apos;toDouble&apos;, function(val)&#123; return val * 2;&#125;);// 双向过滤器 v-model Vue.filter(&apos;modelVal&apos;, &#123; read: function(val)&#123; return val &#125;, write: function(val)&#123; return val; &#125;&#125;)// 全局自定义指令// &lt;span v-red&gt;abc&lt;/span&gt;Vue.directive(&apos;red&apos;, function()&#123; //this.el 绑定该指令的元素(原生dom元素) this.el.style.background = &apos;red&apos;;&#125;);// 自定义元素指令 elementDirective// 自定义键盘// @keydown.ctrl = &quot;show()&quot;// @keydown.mycustomenter = &quot;show()&quot;Vue.directive(&apos;on&apos;).keyCodes.ctrl = 17 // @1.xVue.directive(&apos;on&apos;).keyCodes.mycustomenter = 13 //@1.x// Vue.config.keyCodes.ctrl=17 //@2.x// 监听数据变化vm.$watch(&apos;a&apos;, function()&#123;&#125;);// vm.$watch(&apos;obj&apos;, function()&#123;&#125;, &#123;deep: true&#125;);检测对象 自定义组件全局组件方法1： 123456789101112131415161718192021&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;custom&gt;&lt;/custom&gt; &lt;/div&gt; &lt;script&gt; // only: vue@1.x can use var Custom = Vue.extend(&#123; data: function()&#123; return &#123; title: &apos;我是自定义标题&apos; &#125; &#125;, template: &apos;&lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;/h3&gt;&apos; &#125;) Vue.component(&apos;custom&apos;, Custom); var vm = new Vue(&#123; el: &apos;#box&apos;, &#125;) &lt;/script&gt;&lt;/body&gt; 方法2：123Vue.component(&apos;custom&apos;, &#123; template: &apos;&lt;h3&gt;我是自定义模板&lt;/h3&gt;&apos;&#125;) 局部组件方法1：12345678910var Custom = Vue.extend(&#123; template: &apos;&lt;h3&gt;我是自定义模板&lt;/h3&gt;&apos;&#125;)var vm = new Vue(&#123; el: &apos;#box&apos;, components: &#123; custom: Custom &#125;&#125;) 方法2：12345678new Vue(&#123; el: &apos;#box&apos;, components: &#123; custom: &#123; template: &apos;&lt;h3&gt;我是自定义模板&lt;/h3&gt;&apos; &#125; &#125;&#125;) 讲模板中的html提取到外部12345678910111213&lt;template id=&quot;custom&quot;&gt; &lt;h3&gt;我是自定义模板&lt;/h3&gt;&lt;/template&gt;&lt;script&gt; new Vue(&#123; el: &apos;#box&apos;, components: &#123; custom: &#123; template: &apos;#custom&apos; &#125; &#125; &#125;)&lt;/script&gt; 动态组件123456789101112131415161718192021&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;component :is=&quot;custom&quot;&gt;&lt;/component&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &apos;#box&apos;, data: &#123; custom: &apos;a&apos; &#125;, components: &#123; a: &#123; template: &apos;&lt;h1&gt;我是a&lt;/h1&gt;&apos; &#125;, b: &#123; template: &apos;&lt;h1&gt;我是b&lt;/h1&gt;&apos; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 调试工具dev-tools 父-&gt;子组件数据传递props [‘msg’] { msg: String, num: Number} 12345678910111213141516171819202122&lt;body&gt; &lt;div id=&quot;box&quot;&gt; // @1.x中 .sync子组件更改，同步到父组件 // @2.x中，不允许使用.sync了 &lt;custom :root.sync=&quot;root&quot; :my-msg=&quot;msg&quot;&gt;&lt;/custom&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &apos;#box&apos;, data: &#123; root: &apos;root var&apos; msg: &apos;my msg&apos; &#125;, components: &#123; custom: &#123; props: [&apos;root&apos;, &apos;myMsg&apos;], template: &apos;&lt;h3&gt;&#123;&#123;root&#125;&#125; - &#123;&#123;myMsg&#125;&#125;&lt;/h3&gt;&apos; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 子-&gt;父组件数据传递$emit: 发送 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;custom @child-msg=&quot;get&quot;&gt;&lt;/custom&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &apos;#box&apos;, data: &#123;&#125;, methods: &#123; get: function(msg)&#123; // msg: &apos;sub title&apos; &#125; &#125;, components: &#123; custom: &#123; template: &apos;&lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;/h3&gt;&apos; data: function()&#123; return &#123; title: &apos;sub title&apos; &#125; &#125;, methods: &#123; send: function()&#123; this.$emit(&apos;child-msg&apos;, this.title) &#125; &#125; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; slot 槽口匿名slot12345678910111213141516171819202122&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;custom&gt; &lt;p&gt;I&apos;m use slot&lt;/p&gt; &lt;/custom&gt; &lt;/div&gt; &lt;template id=&quot;custom&quot;&gt; &lt;h3&gt;我是自定义模板&lt;/h3&gt; &lt;slot&gt;为空的默认值&lt;/slot&gt; &lt;p&gt;footer&lt;/p&gt; &lt;/template&gt; &lt;script&gt; new Vue(&#123; el: &apos;#box&apos;, components: &#123; custom: &#123; template: &apos;#custom&apos; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 命名slot12345678910&lt;custom&gt; &lt;p slot=&quot;slot1&quot;&gt;I&apos;m use slot&lt;/p&gt; &lt;p slot=&quot;slot2&quot;&gt;I&apos;m use slot&lt;/p&gt;&lt;/custom&gt;&lt;template id=&quot;custom&quot;&gt; &lt;h3&gt;我是自定义模板&lt;/h3&gt; &lt;slot name=&quot;slot1&quot;&gt;为空的slot1默认值&lt;/slot&gt; &lt;slot name=&quot;slot2&quot;&gt;为空的slot2默认值&lt;/slot&gt; &lt;p&gt;footer&lt;/p&gt;&lt;/template&gt; vue-router]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ruby基础]]></title>
    <url>%2F2017%2F03%2F23%2Fruby%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[闭包use block123456def foo a = 3 yield aendfoo &#123;|b| puts b&#125; use &amp; and call123456def foo(&amp;block) a = 2 block.call(a)endfoo &#123;|a| puts a&#125; procproc可以看做是block的对象表示，类名为Proc1proc = Proc.new &#123;|x| x*2&#125; lambdalambda的class也是Proc1lambda = lambda &#123;|x| x*2&#125; lambda和proc的区别是： 实例化方式的不同而已，proc更像对象，lambda更像方法 1234567891011121314151617## diff1p = Proc.new &#123;|x, y| p x,y&#125;p.call(1) # 1, nilp.call(1,2) # 1,2p.cal(1,2,3) # 1,2l = lambda &#123;|x,y| p x,y&#125;l.call(1) # errl.call(1,2) # 1,2l.call(1,2,3) # err## diff2p = Proc.new &#123;|x| return x&#125;p.call(1) # errl = lambda &#123;|x| return x&#125;p.call(1) # 1 Class基础类示例1234567891011121314151617181920212223242526272829class Point attr_accessor :x # getter setter attr_reader :y # getter @@origin = 0 ORIGIN = 2 # 常量 # 取值 Point::ORIGIN def initialize(x = 0, y = 0) # @x 实例变量 # @@x 类变量 # $x 全局变量 # x 局部变量 @x = x @y = y end # 实例方法 def +(p2) Point.new(x+p2.x, y+p2.y) end # 类方法 def self.foo end # 内部定义的都是类方法 class &lt;&lt; self def bar end endend 继承 public visibility: in/out inheritance: Yes call an obj: Yes protected visibility: within inheritance: Yes call an obj: Yes private visibility: within inheritance: Yes call an obj: No 1234567class Point3D &lt; Point def initialize(x=0, y=0, z=0) # @x, @y, @z = x, y , z super(x, y) @z = z endend module include 引入成实例方法 extend 引入成类方法123456789101112131415161718module Helper # instance method def test end # 类方法 module ClassMethods def test2 end end # hook klass为引入的类这里是 Point def self.included(klass) klass.extend ClassMethods endend# Point classclass Point include Helperend 方法优先级：singleton中的方法 - 实例方法 - module方法 - 父类实例方法 异常处理产生： raise处理： rescue12345678def foo begin # raise &quot;boom in foo&quot; raise TypeError, &quot;boom in foo&quot;, caller rescue =&gt; e puts e endend 枚举和比较模块Comparable12345678910class People attr_reader :name include Comparable def initialize name @name = name end def &lt;=&gt; other self.name &lt;=&gt; other.name endend Enumerable12345678910111213class People attr_reader :people include Enumerable def initialize people @people = people end def each raise &quot;please provide a block&quot; unless block_given? people.each do |person| yield person end endend 正则表达式生成正则的方法 /ruby/ %r{ruby} Regexp.new 使用123&quot;ruby&quot; =~ /ruby/ # 0&quot;ruby&quot;.match(/ru/) # ru&quot;ruby&quot;.gsub!(/r/, i) # iuby 正则编写测试网站123456789101112131415161718192021222324252627282930[abc] A single character of: a, b, or c[^abc] Any single character except: a, b, or c[a-z] Any single character in the range a-z[a-zA-Z] Any single character in the range a-z or A-Z^ Start of line$ End of line\A Start of string\z End of string. Any single character\s Any whitespace character\S Any non-whitespace character\d Any digit\D Any non-digit\w Any word character (letter, number, underscore)\W Any non-word character\b Any word boundary(...) Capture everything enclosed(a|b) a or ba? Zero or one of aa* Zero or more of aa+ One or more of aa&#123;3&#125; Exactly 3 of aa&#123;3,&#125; 3 or more of aa&#123;3,6&#125; Between 3 and 6 of aoptions: i case insensitive m make dot match newlines x ignore whitespace in regex o perform #&#123;...&#125; substitutions only once 时间、日期 DateTime &lt; Date Time # core library1234# 设置环境变量time zoneENV[&apos;TZ&apos;] = &apos;Asia/Shanghai&apos;# 或者Time.now.new_offset(Rational(8,24)) 文件操作file-doc 2.2.0 多线程示例12345678910111213141516171819def foo Thread.current[&apos;a&apos;] = 1 10.times do puts &apos;foo&apos; endenddef bar 10.times do puts &apos;bar&apos; endendt1 = Thread.new &#123;foo()&#125;t2 = Thread.new &#123;bar()&#125;t1.joint2.join # 这里主线程等待t1,t2执行完成，才继续主线程执行，否则主线程停止，子线程将被释放puts t1[&apos;a&apos;] # 1 Thread.new 创建线程 t1.priority = -1 t1.priority = 1 # 设置优先 t1.join 开始执行t1线程,主线程等待t1完成 Thread.current # 当前线程对象 Thread.abort_on_exception = true # 一个线程异常，所有线程都退出 mutex 123456789101112mutex = Mutex.newcount1 = count2 = 0Thread.new doloop do mutex.synchronize do # 类似ios的线程锁！ count1 += 1 count2 += 1 end endendsleep(1)mutex.lock 元编程（metaprogramming）eval 12eval &quot;1 + 1&quot;eval &quot;def foo; puts &apos;foo&apos;; end&quot; instance_eval 12String.instance_eval &quot;def foo; puts &apos;instance_eval foo&apos;; end&quot;String.foo #输出 instance_eval foo class_eval 123String.class_eval &quot;def foo; puts &apos;class_eval foo&apos;; end&quot;str = &apos;abc&apos;str.foo #输出： class_eval foo define_method 123define_method(:foo) &#123; puts &apos;abc&apos; &#125;# 带一个参数的方法定义define_method(:foo) &#123;|arg| puts arg &#125; 12345def method_missing method_nameself.class.send(:define_method, method_name)&#123; puts method_name &#125;end 编写gem 封装class module 讲文件放到lib test bin等目录中 编写gemspec文件 gem build gemspec_file 发布gem rubygems.org注册账号 设置账号与电脑绑定 gem push gem_name]]></content>
      <categories>
        <category>ruby</category>
      </categories>
      <tags>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Active Record]]></title>
    <url>%2F2017%2F03%2F05%2FActive-Record%2F</url>
    <content type="text"><![CDATA[数据类型rails中在mysql，postgresql， sqlite中的类型对照表参考 Rails mysql postgresql sqlite :binary blob bytea blob :boolean tinyint(1) boolean boolean :date date date date :datetime datetime timestamp datetime :decimal decimal decimal decimal :float float float float :integer int(11) integer integer :string varchar(255) * varchar(255) :text text text text :time time time datetime :timestamp datetime timestamp datetime 初始化项目创建项目123$ rails new wechat$ rails new wechat [--skip-bundle] # skip bundle install$ rails new wechat -d mysql # use mysql as database 创建model1rails g model User username:string phone:string:index age:integer 执行与回滚迁移文件1234bundle exec rake db:migratebundle exec rake db:rollback# 回滚两步bundle exec rake db:rollback STEP=2 进入控制台1rails c 数据模型创建users表1$ rails g model User phone:string:index email:string age:integer 修改数据表假设数据库中的表名为USER，显式指定User模型关联USER数据表，负责默认表名为：users123class User &lt; ActiveRecord::Base self.table_name = "USER"end 控制器1$ rails g controller users index new edit show 迁移文件执行迁移文件1$ bundle exec rake db:migrate 回滚迁移文件1$ bundle exec rake db:rollback 数据验证 presence [必须存在]1234567validates :name, presence: true# 只在创建时候验证validates :name, presence: &#123;on: :create&#125;# 只在更新时验证validates :name, presence: &#123;on: :update&#125;# &apos;自定义错误内容&apos;validates :name, presence: &#123;on: :create, message: &apos;姓名不能为空&apos;&#125; absence [必须为空]1validates :name, absence: true length maximum 最大长度 length: {maximum: 255} minimum 最小长度 length: {minimum: 3} in 范围 length: {in: 3..20} is 长度必须为多少 length: {is: 5} confirmation 确认性验证1validates :password, confirmation: true #password_confirmation[shouldn't nil] inclusion 包含性验证[province必须为北京或者上海]1validates :province, inclusion: &#123;in: [&apos;北京&apos;, &apos;上海&apos;]&#125; exclusion 不包含性验证[不在某个集合之内] format 正则匹配1234class User &lt; ActiveRecord::Base EMAIL = /\A.+@.+\z/i # 常量 正则 validates :email, presence: true, length: &#123;maximum: 255&#125;, format: &#123;with: EMAIL&#125;end uniqueness 唯一123class User &lt; ActiveRecord::Base validates :phone, uniqueness: trueend 允许为空的唯一性验证 和 条件验证12345678910111213141516171819202122class User &lt; ActiveRecord::Base # 存在验证唯一，或者可以为空 validates :phone, uniqueness: &#123;allow_nil: true&#125; # method1 validates :phone, uniqueness: &#123;allow_blank: true&#125; # method2 # 条件验证1[fun] 仅仅方法返回true才进行验证 validates :phone, uniqueness: true, :if =&gt; :test? def test? false end # 条件验证2[string] 用户名为空进行验证 validates :phone, uniqueness: true, :if =&gt; &quot;name.nil?&quot; # 条件验证3[proc] validates :phone, uniqueness: true, :if =&gt; Proc.new &#123;name.nil?&#125; # 条件验证 test? 成立 才会内部代码块的验证 with_options if: :test? do validates :name, presence: true validates :phone, presence: true end def test? do (1+1 == 2) endend 自定义验证 validates_with 12345678910111213class MyValidator &lt; ActiveModel::Validator def validate(record) if record.name.nil? record.errors[:name] &lt;&lt; &apos;用户名不能为空&apos; end if record.phone.nil? record.errors[:name] &lt;&lt; &apos;手机号不能为空&apos; end endendclass User &lt; ActiveRecord::Base validates_with MyValidatorend validates_each 1234567891011class NamepresenceValidator &lt; ActiveModel::EachValidator # 参数： 记录 属性 值 def validate_each(record, attribute, value) if vale.nil? record.erros[attribute] &lt;&lt; &quot;用户名不能为空&quot; end endendclass User &lt; ActiveRecord::Base validates :name, namepresence: trueend 自定义验证方法12345678class User &lt; ActiveRecord::Base validate :my_validator def my_validator if name.nil? errors[:name] &lt;&lt; &apos;姓名不能为空&apos; end endend 判断数据是否合法 valid? 判断是否合法 invalid? 判断是否不合法 验证错误信息1234u = User.newu.valid? # if falseu.errors.messages # return hashu.errors[:name] # name属性不合法的信息描述 跳过数据验证方法 save(validate: false) update_all update_column update_columns update_attibute update_counters touch toggle! increment_counter increment! decrement_counter decrement! 验证失败错误信息123456789101112# 创建u = User.new# 验证u.valid?# 查看验证错误信息u.errors.messages# 添加name属性的错误信息u.errors[:name] &lt; &apos;用户名不能为空&apos;# 等价于u.errors.add(:name, &apos;用户名不能为空&apos;)# 查看错误条数u.errors.size 回调可用的回调创建对象回调 before_validation after_validation before_save before_create after_create after_save 更新对象 before_validation after_validation before_save before_update after_update after_save 销毁对象 before_destroy after_dstroy 事务回调 after_commit #事务提交成功后执行 after_rollback #事务提交失败执行 可以触发回调的方法 create create! decrement! destroy destroy! destroy_all increment! save save! save(validate: false) toggle! update_attribute update update! valid? 跳过回调 decrement decrement_count delete delete_all increment increment_counter toggle touch update_column 终止回调before_* 返回false 抛出异常 after_* 抛出异常 条件回调 [和验证的条件回调类似]eg:123456789101112class User &lt; ActiveRecord::Base # 仅仅当创建的时候执行AfterCommit after_commit :AfterCommit, on: :create # test? 为真， 才会执行BeforeSave before_save :BeforeSave, if: :test? def test? true end def BeforeSave puts &apos;before_save&apos; endend]]></content>
      <categories>
        <category>ruby on rails</category>
      </categories>
      <tags>
        <tag>rails</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ruby环境搭建]]></title>
    <url>%2F2017%2F03%2F04%2Fruby%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[安装配置rvm ruby .. ruby-china wike RVM安装ruby查看安装的ruby1rvm list 安装指定版本ruby1rvm install ruby 2.2.2 使用制定版本ruby1rvm use 2.2.2 gem源更换查看所有gem源1$ gem sources -l 移除一个gem源1$ gem sources --remove https://rubygems.org/ 添加一个gem源1$ gem source -a https://gems.ruby-china.org 安装railsgem安装rails1$ gem install rails -v 4.2.3 rails创建项目1$ rails new [myPro] [--skip-bundle] 路由配置eg:1234567891011121314151617181920# 手动配置posts的show路由 as配置路由名称 # get &apos;posts/:id&apos;, :to =&gt; &apos;posts#show&apos;, :as =&gt; &apos;show_post&apos; # 排除show路由 # resources :posts, :except =&gt; :show resources :posts do # posts/recent # get &apos;recent&apos;, :on =&gt; :collection # 集合路由 collection do # posts/recent get &apos;recent&apos; end # 成员路由 member do # posts/:id/recent get &apos;recent&apos; end end]]></content>
  </entry>
  <entry>
    <title><![CDATA[函数去抖动之debounce]]></title>
    <url>%2F2017%2F02%2F25%2F%E5%87%BD%E6%95%B0%E5%8E%BB%E6%8A%96%E5%8A%A8%E4%B9%8Bdebounce%2F</url>
    <content type="text"><![CDATA[snippet-key @js function debounce underscore v1.7.0相关的源码剖123456789101112131415161718192021222324252627282930313233343536// underscore v1.7.0相关的源码剖_.debounce = function(func, wait, immediate) &#123; // immediate默认为false var timeout, args, context, timestamp, result; var later = function() &#123; // 当wait指定的时间间隔期间多次调用_.debounce返回的函数，则会不断更新timestamp的值，导致last &lt; wait &amp;&amp; last &gt;= 0一直为true，从而不断启动新的计时器延时执行func var last = _.now() - timestamp; if (last &lt; wait &amp;&amp; last &gt;= 0) &#123; timeout = setTimeout(later, wait - last); &#125; else &#123; timeout = null; if (!immediate) &#123; result = func.apply(context, args); if (!timeout) context = args = null; &#125; &#125; &#125;; return function() &#123; context = this; args = arguments; timestamp = _.now(); // 第一次调用该方法时，且immediate为true，则调用func函数 var callNow = immediate &amp;&amp; !timeout; // 在wait指定的时间间隔内首次调用该方法，则启动计时器定时调用func函数 if (!timeout) timeout = setTimeout(later, wait); if (callNow) &#123; result = func.apply(context, args); context = args = null; &#125; return result; &#125;; &#125;; 个人实现 功能和underscore实现一样， 去除了underscore的依赖 1234567891011121314151617181920212223242526272829303132333435363738394041 /** * 包裹函数 一段时间间隔只执行函数一次 * @param funcRef 函数引用 * @param wait default, 300ms * 是否立即触发，触发后wait时间内不触发该方法，wait时间后才可以重新触发 * false：wait后触发 没有返回值 * true: wait前触发, 可以有返回值 * @param immediate default false * return : 返回新的函数，使用：将需要调用funcRef的地方，替换为调用新返回的函数即可 */function debounce(funcRef, wait, immediate) &#123; var context, args, timestamp, timeout; wait = wait || 300; return function () &#123; context = this; args = arguments; timestamp = new Date().getTime(); var nowCall = immediate &amp;&amp; !timeout; if(!timeout)&#123; timeout = setTimeout(later, wait) &#125; if(nowCall)&#123; var result = funcRef.apply(context, arguments); context = args = null; return result; &#125; &#125;; function later() &#123; // 当wait指定的时间间隔期间多次调用_.debounce返回的函数，则会不断更新timestamp的值，导致last &lt; wait &amp;&amp; last &gt;= 0一直为true，从而不断启动新的计时器延时执行func var last = new Date().getTime() - timestamp; if (last &lt; wait &amp;&amp; last &gt;= 0) &#123; timeout = setTimeout(later, wait - last); &#125;else &#123; timeout = null; if (!immediate) &#123; funcRef.apply(context, args); if (!timeout) context = args = null; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>debounce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2017%2F02%2F22%2F%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BAvue-webkpack%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[命令大全 删除git代码管理中已经提交的服务器的提交123#git reset --hard HEAD~1 # 取消当前版本之前的一次提交git reset --hard HEAD~2 # 取消当前版本之前的两次提交git push origin HEAD --force # 强制提交到远程版本库，从而删除之前的两次提交数据 在mac中自动保存git用户名与密码如此简单在Mac OS X中这个操作竟然如此简单。只需在Terminal中输入如下的命令：1git config --global credential.helper osxkeychain 然后在git操作时只要输入一次用户名与密码，以后就不用输入了。 【参考资料】 Git keeps prompting me for password]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular中$filter过滤器的使用]]></title>
    <url>%2F2017%2F02%2F18%2Fangular%E4%B8%AD-filter%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[系统提供过滤器currency（货币处理）1&#123;&#123;num | currency : '￥'&#125;&#125; //默认为 '$' date（日期格式化）更详细配置参见这里123456&#123;&#123; today | date:'yyyy-MM-dd' &#125;&#125; //2015-01-01# y M d h m s E 分别表示 年 月 日 时 分 秒 星期# 年月日：(&#123;&#123; today | date:'yyyy-MM-dd' &#125;&#125;) 2015-10-19# 时分秒：(&#123;&#123; today | date:'HH:mm:ss.sss' &#125;&#125;) 10:02:15.701# 英文星期：(&#123;&#123; today | date:'EEEE' &#125;&#125;)Monday# 英文星期简写：(&#123;&#123; today | date:'EEE' &#125;&#125;)Mon filter（匹配字串）123456789101112$scope.childrenArray = [ &#123;name:'kimi',age:3&#125;, &#123;name:'cindy',age:4&#125;, &#123;name:'anglar',age:4&#125;, &#123;name:'shitou',age:6&#125;, &#123;name:'tiantian',age:5&#125; ];$scope.func = function(e)&#123;return e.age&gt;4;&#125;&#123;&#123; childrenArray | filter : 'a' &#125;&#125; //匹配属性值中含有a的&#123;&#123; childrenArray | filter : 4 &#125;&#125; //匹配属性值中含有4的&#123;&#123; childrenArray | filter : &#123;name : 'i'&#125; &#125;&#125; //参数是对象，匹配name属性中含有i的&#123;&#123;childrenArray | filter : func &#125;&#125; //参数是函数，指定返回age&gt;4的 json（对象格式化成json字符串）1&#123;&#123; jsonTest | json&#125;&#125; //没有参数。这东西有什么用呢，我一般也不会在页面上输出一个json串啊，官网说它可以用来进行调试，嗯，是个不错的选择。 limitTo（限制数组长度或者字符串长度）12#有点鸡肋，首先只能从数组或字符串的开头进行截取，其次，js原生的函数就可以代替它了&#123;&#123; childrenArray | limitTo : 2 &#125;&#125; //将会显示数组中的前两项 lowercase（小写）uppercase（大写）number（格式化数字）12345678//在html中用法&#123;&#123; number_expression | number : fractionSize&#125;&#125;//在js中用法$filter('number')(number, fractionSize)//参数//number 待精确的数字//factionSize(可选) 小数点后精确位数，默认值是3.#(默认情况下保留的小数位数小于等于3. 比如: 1234--&gt;1234；1234.56789--&gt;1234.568；1234.56--&gt;1234.56 ) orderBy （排序） 自定义过滤器123456789101112131415//定义filters modulevar filters = angular.module('filters', []); filters.filter('stringAdd',function()&#123; return function (obj, addString) &#123; return obj + addString; &#125;&#125;);//html中使用&#123;&#123; '07' | stringAdd:':00' &#125;&#125; // 07:00// js中使用# 注入$filter$filter('stringAdd')('07', ':00'); // 07:00// 过滤器有对个参数用 ：隔开// &#123;&#123; yourExpression | yourFilter: arg1:arg2:... &#125;&#125;]]></content>
      <categories>
        <category>angular.js</category>
      </categories>
      <tags>
        <tag>$filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis的安装和配置]]></title>
    <url>%2F2017%2F02%2F18%2Fredis%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[【参考】 安装Redis123456789101112131415161718# 希望将redis安装到此目录 /usr/local/redis# 希望将安装包下载到此目录 /usr/local/src那么安装过程指令如下： $ mkdir /usr/local/redis $ cd /usr/local/src $ wget http://download.redis.io/releases/redis-3.0.7.tar.gz$ tar xzf redis-3.0.7.tar.gz$ cd redis-3.0.7$ make PREFIX=/usr/local/redis install #安装到指定目录中#如果make失败，一般是你们系统中还未安装gcc,那么可以通过yum安装： $ yum install gcc#在安装redis成功后，你将可以在/usr/local/redis看到一个bin的目录，里面包括了以下文件： redis-benchmark redis-check-aof redis-check-dump redis-cli redis-server 将Redis做成服务redis默认运行脚本 ps: /etc/init.d/目录下的脚本就类似与windows中的注册表，在系统启动的时候某些指定脚本将被执行 按以上步骤安装Redi时，其服务脚本位于：/usr/local/src/redis-3.0.7/utils/redis_init_script 拷贝脚本到/etc/init.d/目录下，并命名为redis1$ [sudo] cp /usr/local/src/redis-3.0.7/utils/redis_init_script /etc/init.d/redis 对启动脚本进行修改打开redis脚本文件，并进行编辑123456789$ vim /etc/init.d/redis#修改到正确的路径#EXEC=/usr/local/bin/redis-serverEXEC=/usr/local/redis/bin/redis-server#CLIEXEC=/usr/local/bin/redis-cliCLIEXEC=/usr/local/redis/bin/redis-cli# 设置配置文件路径#CONF="/etc/redis/$&#123;REDISPORT&#125;.conf" 配置Redis启动信息在上面shell脚本指定的配置目录中创建文件，并进行编辑。更详细配置参考这里1234567891011121314151617181920212223242526272829303132$ [sudo] mkdir /etc/redis/$ [sudo] vim /etc/redis/6379.conf写入配置:#!/bin/sh# 是否以后台进程运行，默认为nodaemonize yes# 如以后台进程运行，则需指定一个pid，默认为/var/run/redis.pidpidfile /var/run/redis.pid# 监听端口，默认为6379port 6379#绑定主机IP，默认值为127.0.0.1（注释）bind 127.0.0.1# 超时时间，默认为300（秒）timeout 300# 日志记录等级，有4个可选值，debug，verbose（默认值），notice，warningloglevel verbose#可用数据库数，默认值为16，默认数据库为0databases 16#指出在多长时间内，有多少次更新操作，就将数据同步到数据文件。这个可以多个条件配合，比如默认配置文件中的设置，就设置了三个条件。# 900秒（15分钟）内至少有1个key被改变save 900 1# 300秒（5分钟）内至少有10个key被改变save 300 10# 存储至本地数据库时是否压缩数据，默认为yesrdbcompression yes# 本地数据库文件名，默认值为dump.rdbdbfilename dump.rdb# 本地数据库存放路径，默认值为 ./dir /usr/apps/redis_db#开启之后，redis将在每100毫秒时使用1毫秒的CPU时间来对redis的hash表进行重新hash，可以降低内存的使用。当你的使 用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存activerehashing yes 启动redis服务手动启动命令1$ service redis start 方便redis客户端的使用，可以将Redis的所在目录添加到系统参数PATH中 修改profile文件：/etc/profile 最文件最后一行添加export PATH=&quot;$PATH:/usr/local/redis/bin&quot; 应用配置执行12345678910$ . /etc/profile ``` * 至此可以直径调用redis-cli的命令了```bash$ redis-cli redis 127.0.0.1:6379&gt; auth superman OK redis 127.0.0.1:6379&gt; ping PONG redis 127.0.0.1:6379&gt;]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>install</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内置Promise的使用]]></title>
    <url>%2F2017%2F02%2F18%2F%E5%86%85%E7%BD%AEPromise%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[引入方法高版本node已经内嵌了Promise机制 1var Promise = require('promise'); 简单使用 new Promise依赖关系顺序执行12345678910111213141516function testPromise(begin) &#123; return new Promise(function (resolve, reject) &#123; // 在这里写异步方法, resolve是then的第一个参数, reject是then的第二个参数 if (begin &lt;= 3)&#123; resolve(begin); &#125; reject('begin 不允许 &gt; 3'); &#125;).then(function (begin) &#123; console.log(begin); &#125;, function(err)&#123; console.log(err); &#125;);&#125;// 调用测试testPromise(0); // 0testPromise(4); // begin 不允许 &gt; 3 高级使用 new Promise.all非依赖同时执行123456789101112131415161718function onePromise(begin) &#123; return new Promise(function (resolve, reject) &#123; if (begin &lt;= 3)&#123; resolve(begin); &#125; reject('begin = '+ begin +' 不允许 &gt; 3'); &#125;);&#125;function testPromise2(begin)&#123; return new Promise.all([onePromise(begin), onePromise(begin+1), onePromise(begin+2)]).then(function(datas)&#123; console.log(datas); &#125;, function(err)&#123; console.log(err); &#125;)&#125;// 调用测试testPromise2(1); // [ 1, 2, 3 ]testPromise2(2); // begin = 4 不允许 &gt; 3 其他Promise 第三方库 如果node版本较低,可以使用其他实现Promise标准的库 bluebird github Q github Deferredgithub thengithub whengithub asyncgithub eventproxy(事件驱动)github]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局资料]]></title>
    <url>%2F2017%2F02%2F18%2Fflex%E5%B8%83%E5%B1%80%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[Flex 布局教程：语法篇 http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool flexFlex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。 123.box&#123; display: inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 flex属性容器的属性 flex-direction row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap：wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-contentjustify-content属性定义了项目在主轴上的对齐方式。123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-itemsalign-items属性定义项目在交叉轴上如何对齐。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-contentalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性orderorder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.item &#123; order: &lt;integer&gt;;&#125; flex-growflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrinkflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 flex-basisflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flexflex属性是flex-grow,flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node的http模块]]></title>
    <url>%2F2017%2F02%2F18%2Fnode%E7%9A%84http%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[创建简单服务器参考123456var http = require(&apos;http&apos;);http.createServer(function (request, response) &#123; response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;); response.end(&apos;Hello World\n&apos;);&#125;).listen(1337, &apos;127.0.0.1&apos;);console.log(&apos;Server running at http://127.0.0.1:1337/&apos;); 根据url下载文件123456789101112131415161718var http = require('http');var fs = require('fs');var url = 'http://www.baidu.com/dd2.jpg';var downloadFilePath = '/c/abc.png';var file = fs.createWriteStream(downloadFilePath, &#123;flags: 'w'&#125;);var req = http.get(url, function (res) &#123; res.pipe(file, &#123;end: 'false'&#125;); res.on('end', function () &#123; file.end(); console.log('download success'); &#125;).on('error', function(e) &#123; console.log('error:', e); &#125;);&#125;);req.on('error', function(err)&#123; //错误处理，处理res无法处理到的错误 console.error('download file error out:', url);&#125;);]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件注册码]]></title>
    <url>%2F2017%2F02%2F18%2F%E8%BD%AF%E4%BB%B6%E6%B3%A8%E5%86%8C%E7%A0%81%2F</url>
    <content type="text"><![CDATA[sublime312345678910111213—– BEGIN LICENSE —–Michael BarnesSingle User LicenseEA7E-8213858A353C41 872A0D5C DF9B2950 AFF6F667C458EA6D 8EA3C286 98D1D650 131A97ABAA919AEC EF20E143 B361B1E7 4C8B7F04B085E65E 2F5F5360 8489D422 FB8FC1AA93F6323C FD7F7544 3F39C318 D95E6480FCCC7561 8A4A1741 68FA4223 ADCEDE07200C25BE DBBC4855 C4CFB774 C5EC138C0FEC1CEF D9DCECEC D3A5DAD1 01316C36—— END LICENSE —— 12345678910111213—– BEGIN LICENSE —–Alexey PlutalovSingle User LicenseEA7E-8607763DC19CC1 134CDF23 504DC871 2DE5CE55585DC8A6 253BB0D9 637C87A2 D8D0BA85AAE574AD BA7D6DA9 2B9773F2 324C5DEF17830A4E FBCF9D1D 182406E9 F883EA87E585BBA1 2538C270 E2E857C2 194283CA7234FF9E D0392F93 1D16E021 F191491763909E12 203C0169 3F08FFC8 86D06EA873DDAEF0 AC559F30 A6A67947 B60104C6—— END LICENSE —— webstormonline get:1http://idea.lanyus.com/]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>注册码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件对象（event）]]></title>
    <url>%2F2017%2F02%2F18%2F%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%EF%BC%88event%EF%BC%89%2F</url>
    <content type="text"><![CDATA[onabort 图像加载被中断 onblur 元素失去焦点 onchange 用户改变域的内容 onclick 鼠标点击某个对象 ondblclick 鼠标双击某个对象 onerror 当加载文档或图像时发生某个错误 onfocus 元素获得焦点 onkeydown 某个键盘的键被按下 onkeypress 某个键盘的键被按下或按住 onkeyup 某个键盘的键被松开 onload 某个页面或图像被完成加载 onmousedown 某个鼠标按键被按下 onmousemove 鼠标被移动 onmouseout 鼠标从某元素移开 onmouseover 鼠标被移到某元素之上 onmouseup 某个鼠标按键被松开 onreset 重置按钮被点击 onresize 窗口或框架被调整尺寸 onselect 文本被选定 onsubmit 提交按钮被点击 onunload 用户退出页面 event对象有哪些属性或者方法 type：事件类型。用来描述这个事件是什么类型的，比如onclick的事件类型为click。 srcElement/target：事件源，就是发生事件的元素； FF下是target，IE下是srcElement cancelBubble：一个布尔属性，把它设置为true的时候，将停止事件进一步起泡到包容层次的元素；(e.cancelBubble = true; 相当于 e.stopPropagation();) 。FF下是后者。 keyCode: 这个不陌生了吧。也非常的常用，用来判断你按下了哪个键 attachEvent(), detachEvent()/addEventListener(), removeEventListener：为指定DOM对象事件类型注册多个事件处理函数的方法，它们有两个参数，第一个是事件类型，第二个是事件处理函数。在 attachEvent()事件执行的时候，this关键字指向的是window对象，而不是发生事件的那个元素； 当然还有其他的一些属性，我这里列出来的都是最常用的。比如还有:button、 clientX,clientY、offsetX,offsetY layerX,layerY、x,y pageX,pageY、altKey,ctrlKey,shiftKey、fromElement,toElement、screenX、screenY。 Event altKey、ctrlKey、shiftKey属性 event.altKey 功能：检测事件发生时Alt键是否被按住了。 语法：event.altKey 取值：true | false 说明：altKey属性为true表示事件发生时Alt键被按下并保持，为false则Alt键没有按下。 altKey属性可结合鼠标或键盘使用，多用于制作一些快捷操作方式。 event.ctrlKey 功能：检测事件发生时Ctrl键是否被按住了。 语法：event.ctrlKey 取值：true | false 说明： ctrlKey属性为true表示事件发生时Ctrl键被按下并保持，为false则Ctrl键没有按下。 ctrlKey属性可结合鼠标或键盘使用，多用于制作一些快捷操作方式。 event.shiftKey 功能：检测事件发生时Shift键是否被按住了。 语法：event.shiftKey 取值：true | false 说明： shiftKey属性为true表示事件发生时Shift键被按下并保持，为false则Shift键没有按下。 shiftKey属性可结合鼠标或键盘使用，多用于制作一些快捷操作方式。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pm2部署服务器]]></title>
    <url>%2F2017%2F02%2F18%2Fpm2%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[基本使用 本地和服务器安装pm2 1$ npm install -g pm2 使用pm2启动应用 1$ pm2 start xxx.js 开发中启动，代码变更后自动重启应用 1$ pm2 start xxx.js --watch cluster模式默认情况下pm2是以fork模式启动应用的，如果以cluster模式启动的话，则可以使用pm2自带的负载均衡、零间断重启等功能。1$ pm2 start xxx.js -i 4 上面的命令会以cluster模式启动4个应用进程，并自动为它们提供负载均衡，并且可以使用gracefulReload达到更新应用时不中断服务的效果。 升级pm212$ npm install -g pm2@latest$ pm2 updatePM2 部署接下来需要建立一个部署的配置文件，这个文件在本机（操作发布的机器）和服务器上都需要有，因此最好放入Git版本管理中，并且推送到远程代码库（Git服务器）。 切换到项目目录下，然后执行1$ pm2 ecosystem 即可得到一个示例json文件123456789101112131415161718192021222324252627282930313233343536&#123;&quot;apps&quot; : [&#123; &quot;name&quot; : &quot;API&quot;, &quot;script&quot; : &quot;app.js&quot;, &quot;env&quot;: &#123; &quot;COMMON_VARIABLE&quot;: &quot;true&quot; &#125;, &quot;env_production&quot; : &#123; &quot;NODE_ENV&quot;: &quot;production&quot; &#125;&#125;,&#123; //没有这个环境可以删除掉 &quot;name&quot; : &quot;WEB&quot;, &quot;script&quot; : &quot;web.js&quot;&#125;],&quot;deploy&quot; : &#123; &quot;production&quot; : &#123; &quot;user&quot; : &quot;node&quot;,//登录账号 &quot;host&quot; : &quot;212.83.163.1&quot;,//服务器地址 &quot;ref&quot; : &quot;origin/master&quot;,//git 分支 &quot;repo&quot; : &quot;git@github.com:wuyuedefeng/node-china.club.git&quot;,//git地址 &quot;path&quot; : &quot;/var/www/production&quot;,//服务器项目目录 &quot;post-deploy&quot; : &quot;pm2 startOrRestart ecosystem.json5 --env production&quot; &#125;, &quot;dev&quot; : &#123; &quot;user&quot; : &quot;node&quot;, &quot;host&quot; : &quot;212.83.163.1&quot;, &quot;ref&quot; : &quot;origin/master&quot;, &quot;repo&quot; : &quot;git@github.com:repo.git&quot;, &quot;path&quot; : &quot;/var/www/development&quot;, &quot;post-deploy&quot; : &quot;pm2 startOrRestart ecosystem.json5 --env dev&quot;, &quot;env&quot; : &#123; &quot;NODE_ENV&quot;: &quot;dev&quot; &#125; &#125;&#125;&#125; apps.name和apps.script应该与PM2识别应用有关，后续执行pm2 restart的时候可以对应到进程（未证实） deploy中可以含有多个环境，需要能够通过SSH（公钥认证）登录服务器 web目录并不是真正的放版本库文件的目录，PM2会再建立一个source子目录，这个才是真正放代码的目录 post-deploy是指代码部署完之后执行的命令，这里以Node.js为例子，执行依赖安装，然后重启PM2中的进程 然后就可以使用了 首先需要安装一下1$ pm2 deploy ecosystem.json production setup 如果已经安装可以运行下面这个命令进行部署(需要添加服务器的ssh key到github上)1$ pm2 deploy ecosystem.json production 大功告成！]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>pm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器环境安装nginx： Ubuntu14.04]]></title>
    <url>%2F2017%2F02%2F17%2F%E5%AE%89%E8%A3%85-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%EF%BC%9A-Ubuntu14-04%2F</url>
    <content type="text"><![CDATA[安装服务器环境： Ubuntu14.04 apt-get 安装12$ [sudo] apt-get update $ [sudo] apt-get install nginx 配置文件： (配置文件所在目录：/etc/ngnix/sites-enabled/)12$ cd /etc/nginx/nginx.conf$ vim nodeChinaClub.conf 写入：12345678910server &#123; server_name itrydo.com; location / &#123; proxy_pass http://localhost:8088; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_set_header Host $host; &#125;&#125; 使配置生效：1service nginx reload nginx location模块–匹配规则Location语法语法：location [=|~|~*|^~] /uri/ { … } = –&gt; 开头表示精确匹配 ^~ –&gt; 开头表示uri以某个常规字符串开头，理解为匹配url路径即可。 nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）。 ~ –&gt; 开头表示区分大小写的正则匹配 ~* –&gt; 开头表示不区分大小写的正则匹配 !~和!~* –&gt; 分别为区分大小写不匹配及不区分大小写不匹配的正则 / –&gt; 通用匹配，任何请求都会匹配到。 多个location配置的情况下匹配顺序为： 首先匹配=，其次匹配^~, 其次是按文件中顺序的正则匹配，最后是交给 / 通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。 例子，有如下匹配规则：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950location = / &#123; #http://localhost/ 访问根目录/ #规则A&#125;location = /login &#123; #http://localhost/login #规则B&#125;location ^~ /static/ &#123; #http://localhost/static/a.html #http://localhost/static/c.png 则优先匹配到 规则C #规则C&#125;#http://localhost/a.gif, http://localhost/b.jpg 将匹配规则D和规则E，但是规则D顺序优先，规则E不起作用，location ~ \.(gif|jpg|png|js|css)$ &#123; #规则D&#125;location ~* \.png$ &#123; #http://localhost/a.PNG 则匹配规则E，而不会匹配规则D，因为规则E不区分大小写。 #规则E&#125;http://localhost/a.xhtml 不会匹配规则F和规则G，http://localhost/a.XHTML 不会匹配规则G，因为不区分大小写。规则F，规则G属于排除法，符合匹配规则但是不会匹配到，所以想想看实际应用中哪里会用到。location !~ \.xhtml$ &#123; #规则F&#125;location !~* \.xhtml$ &#123; #规则G&#125;访问http://localhost/category/id/1111 最终匹配到规则H，因为以上规则都不匹配，这个时候应该是nginx转发请求给后端应用服务器，比如FastCGI（php），tomcat（jsp），nginx作为方向代理服务器存在。location / &#123; #http://localhost/register #规则H&#125; 所以实际使用中，个人觉得至少有三个匹配规则定义，如下：12345678910111213141516171819202122#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。#这里是直接转发给后端应用服务器了，也可以是一个静态首页# 第一个必选规则location = / &#123; proxy_pass http://tomcat:8080/index&#125;# 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项# 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用location ^~ /static/ &#123; root /webroot/static/;&#125;location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123; root /webroot/res/;&#125;#第三个规则就是通用规则，用来转发动态请求到后端应用服务器#非静态文件请求就默认是动态请求，自己根据实际把握#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了location / &#123; proxy_pass http://tomcat:8080/&#125; 对于以上基础推荐配置，有一个补充，就是关于转发有一点需要注意。例如下面配置，对一个目录转发：123456location ^~ /outer/ &#123; #case A： url最后以/结尾 proxy_pass http://tomcat:8080/ #case B： url最后没有/ #proxy_pass http://tomcat:8080 &#125; 关键在于最后的/，访问localhost/outer/in.html，其中case A会转发到tomcat:8080/in.html， 而case B会转发到tomcat:8080/outer/in.html，所以务必注意了。 参考自：http://www.cnblogs.com/linjiqin/p/5532119.html nginx upstream模块–负载均衡upstream模块相关说明 upstream模块应放于nginx.conf配置的http{}标签内 upstream模块默认算法是wrr (权重轮询 weighted round-robin) 一、分配方式 Nginx的upstream支持5种分配方式，下面将会详细介绍，其中前三种为Nginx原生支持的分配方式，后两种为第三方支持的分配方式。 1. 轮询轮询是upstream的默认分配方式，即每个请求按照时间顺序轮流分配到不同的后端服务器，如果某个后端服务器down掉后，能自动剔除。12345upstream backend &#123; server 192.168.1.101:8888; server 192.168.1.102:8888; server 192.168.1.103:8888;&#125; 2. weight轮询的加强版，即可以指定轮询比率，weight和访问几率成正比，主要应用于后端服务器异质的场景下。12345upstream backend &#123; server 192.168.1.101 weight=1; server 192.168.1.102 weight=2; server 192.168.1.103 weight=3;&#125; 3. ip_hash每个请求按照访问ip（即Nginx的前置服务器或者客户端IP）的hash结果分配，这样每个访客会固定访问一个后端服务器，可以解决session一致问题。123456upstream backend &#123; ip_hash; server 192.168.1.101:7777; server 192.168.1.102:8888; server 192.168.1.103:9999;&#125; 注意： 当负载调度算法为ip_hash时，后端服务器在负载均衡调度中的状态不能是weight和backup。 导致负载不均衡。 4. fairfair顾名思义，公平地按照后端服务器的响应时间（rt）来分配请求，响应时间短即rt小的后端服务器优先分配请求。如果需要使用这种调度算法，必须下载Nginx的upstr_fair模块。123456upstream backend &#123; server 192.168.1.101; server 192.168.1.102; server 192.168.1.103; fair;&#125; 5. url_hash，目前用consistent_hash替代url_hash与ip_hash类似，但是按照访问url的hash结果来分配请求，使得每个url定向到同一个后端服务器，主要应用于后端服务器为缓存时的场景下。1234567upstream backend &#123; server 192.168.1.101; server 192.168.1.102; server 192.168.1.103; hash $request_uri; hash_method crc32;&#125; 其中，hash_method为使用的hash算法，需要注意的是：此时，server语句中不能加weight等参数。 提示：url_hash用途cache服务业务，memcached，squid，varnish。特点：每个rs都是不同的。 设备状态从上面实例不难看出upstream中server指令语法如下：server address [parameters] 参数说明： server：关键字，必选。 address：主机名、域名、ip或unix socket，也可以指定端口号，必选。 parameters：可选参数，可选参数如下： down：表示当前server已停用 backup：表示当前server是备用服务器，只有其它非backup后端服务器都挂掉了或者很忙才会分配到请求。 weight：表示当前server负载权重，权重越大被请求几率越大。默认是1. max_fails和fail_timeout一般会关联使用，如果某台server在fail_timeout时间内出现了max_fails次连接失败，那么Nginx会认为其已经挂掉了，从而在fail_timeout时间内不再去请求它，fail_timeout默认是10s，max_fails默认是1，即默认情况是只要发生错误就认为服务器挂掉了，如果将max_fails设置为0，则表示取消这项检查。 参考自：http://www.cnblogs.com/linjiqin/p/5494783.html 80端口部署多个静态网页https://www.digitalocean.com/community/tutorials/how-to-set-up-nginx-server-blocks-virtual-hosts-on-ubuntu-14-04-lts]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>install</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用vue-cli初始化vue项目]]></title>
    <url>%2F2017%2F02%2F17%2F%E4%BD%BF%E7%94%A8vue-cli%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[init1234$ npm install -g vue-cli$ vue init webpack demo$ cd demo$ npm install demo 是这个示例项目的名字 现在看到目录结构如下 build 目录是一些webpack的文件，配置参数什么的，一般不用动 src 源码文件夹，基本上文件都应该放在这里。 static 生成好的文件会放在这个目录下。 test 测试文件夹，测试都写在这里 .babelrc babel编译参数，vue开发需要babel编译 .editorconfig 看名字是编辑器配置文件，不晓得是哪款编辑器，没有使用过。 .eslintrc.js eslint配置文件，用以规范团队开发编码规范，大中型项目很有用 .gitignore 用来过滤一些版本控制的文件，比如node_modules文件夹 index.html 主页 package.json 项目文件，记载着一些命令和依赖还有简要的项目描述信息 README.md 介绍自己这个项目的，想怎么写怎么写。 添加支持 sass 安装依赖包12npm install node-sass --save-devnpm install sass-loader --save-dev style中添加lang=&quot;scss&quot;123// 添加scoped用来生成唯一样式 指定内部样式只对当前组件生效, 不添加scoped样式将作用于全局&lt;style lang=&quot;scss&quot; scoped&gt; &lt;/style&gt; 使用 vue-router 实现单页路由12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;Vue.use(Router)const router = new Router(&#123; routes: [ &#123; path: &apos;/login&apos;, name: &apos;login&apos;, meta: &#123; Auth: false &#125;, component: function (resolve) &#123; require([&apos;views/profiles/Login.vue&apos;], resolve) &#125;, beforeEnter: (to, from, next) =&gt; &#123; next(); &#125; &#125;, &#123; path: &apos;/&apos;, name: &apos;main&apos;, meta: &#123; Auth: true &#125;, component: function (resolve) &#123; require([&apos;components/Main&apos;], resolve) &#125;, children: [ &#123; path: &apos;&apos;, name: &apos;index&apos;, component: function (resolve) &#123; require([&apos;views/Index&apos;], resolve) &#125; &#125;, // 用户管理 &#123; // 以 / 开头的嵌套路径会被当作根路径 path: &apos;/users&apos;, name: &apos;users&apos;, component: function (resolve) &#123; require([&apos;views/users&apos;], resolve) &#125; &#125;, &#123; path: &apos;/users/:userId/edit&apos;, name: &apos;userEdit&apos;, component: function (resolve) &#123; require([&apos;views/users/userEdit&apos;], resolve) &#125; &#125; ] &#125;, &#123; path: &apos;*&apos;, redirect: &apos;/&apos; &#125;, ]&#125;);router.beforeEach((to, from, next) =&gt; &#123; if (to.matched.some(record =&gt; record.meta.Auth) /* &amp;&amp; is not login */) &#123; next(&#123; path: &apos;/login&apos;, query: &#123;redirect: to.fullPath&#125; &#125;) &#125; else&#123; next(); &#125;&#125;)export default router; 文件: 按需加载 用 vuex 管理我们的数据流12345678910111213141516171819// 导入vueximport Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)//导入modulesimport users from &apos;./modules/users&apos;var store = new Vuex.Store(&#123; state: &#123; &#125;, actions: &#123; &#125;, mutations: &#123; &#125;, modules: &#123; users &#125;&#125;) 集成axios到项目中创建http.js12345678910111213141516171819202122232425262728293031323334353637383940414243import axios from 'axios'var store = null;const instance = axios.create();instance.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';// Add a request interceptorinstance.interceptors.request.use(function (config) &#123; // Do something before request is sent return config;&#125;, function (error) &#123; // Do something with request error return Promise.reject(error);&#125;);// Add a response interceptorinstance.interceptors.response.use(function (response) &#123; // Do something with response data if(response.data.code != 10000)&#123; var error = new Error(response.data &amp;&amp; response.data.msg); // alert(error); if(response.data.code == '50007' || response.data.code == '50004')&#123; // store &amp;&amp; store.commit('logout'); &#125; throw error; &#125; return response;&#125;, function (error) &#123; // Do something with response error // alert(error); return Promise.reject(error);&#125;);instance.install = function (Vue, options) &#123; if(options.store) &#123; store = options.store &#125; Vue.prototype.$http = instance; Vue.$http = instance;&#125;;export default instance; usage: eg: in main.js123import $http from &apos;./api/http&apos;Vue.use($http, &#123;store&#125;); then you can use in components1this.$http.get() //equal call axios instanse get or in vuex1Vue.$http.get() 细节，编写自定义插件 请自行参考官方文档 main.js12345678910111213141516import Vue from &apos;vue&apos;import App from &apos;./App&apos;import router from &apos;./router&apos;import store from &apos;./vuex/store&apos;import $http from &apos;./http&apos;Vue.use($http, &#123;store&#125;);/* eslint-disable no-new */new Vue(&#123; el: &apos;#app&apos;, router, store, template: &apos;&lt;App/&gt;&apos;, components: &#123; App &#125;&#125;) 图片路径问题参考 配置alias123456resolve: &#123; extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.vue&apos;], alias: &#123; &apos;assets&apos;: path.resolve(__dirname, &apos;../src/assets&apos;) &#125;&#125; 使用：1&lt;img src=&quot;~asset/pic.png&quot;&gt;&lt;/img&gt; 如果配置了 vue html root12345vue: &#123; html: &#123; root: path.resolve(__dirname, &apos;../src/assets&apos;) &#125;&#125; 则可以在任何子目录中直接写1&lt;img src=&quot;/pic.png&quot;&gt;&lt;/img&gt; 动态渲染的图片 如果是有规律的重复出现的组件通常通过 v-for 来渲染，通过数组或对象来插入数据。比如1234567891011const data = [&#123; title: &apos;title1&apos;, img: &apos;../assets/pic01.png&apos; &#125;, &#123; title: &apos;title2&apos;, img: &apos;../assets/pic02.png&apos;&#125;]&lt;my-compo v-for=&quot;item in data&quot;&gt; &lt;img :src=&quot;item.img&quot;&gt;&lt;/img&gt;&lt;/my-compo&gt; 这样的问题是 webpack 不会对 src 做任何操作，会原样输出导致 404 错误1&lt;img src=&quot;../assets/pic01.png&quot;&gt;&lt;/img&gt; 这是因为渲染操作是在浏览器完成的。解决办法是使用 require 引入图片让 webpack 在 build 的时候就知道要处理它们1234567const data = [&#123; title: &apos;title1&apos;, img: require(&apos;../assets/pic01.png&apos;) &#125;, &#123; title: &apos;title2&apos;, img: require(&apos;../assets/pic02.png&apos;)&#125;] 生成dist相对路径[默认绝对路径]修改 /config/index.js build config 1assetsPublicPath: &apos;/&apos; 改为1assetsPublicPath: &apos;./&apos; dev 和 pro 配置不同的变量比如 api host首先，我们分别找到下面的文件：12/config/dev.env.js/config/prod.env.js dev.en.js文件。代码如下：1234567var merge = require(&apos;webpack-merge&apos;)var prodEnv = require(&apos;./prod.env&apos;)module.exports = merge(prodEnv, &#123; NODE_ENV: &apos;&quot;development&quot;&apos;, API_ROOT: &apos;&quot;http://test.itrydo.com/api&quot;&apos;&#125;) prod.env.js文件:1234module.exports = &#123; NODE_ENV: &apos;&quot;production&quot;&apos;, API_ROOT: &apos;&quot;http://www.baidu.com/api&quot;&apos;&#125; 在代码中调用设置好的参数: 12// 配置API接口地址var root = process.env.API_ROOT 在经过这样的配置之后，我们在运行1npm run dev 的时候，跑的就是测试接口。而我们运行1npm run build 打包项目的时候，打包的是服务器正式接口，我们就不用调来调去得了。 asset img path参考 build/webpack.base.conf.js 如果配置了 alias123456resolve: &#123; extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.vue&apos;], alias: &#123; &apos;assets&apos;: path.resolve(__dirname, &apos;../src/assets&apos;) &#125;&#125; 则可以在任何子目录中直接写1&lt;img src=&quot;~assets/pic.png&quot;&gt;&lt;/img&gt; 动态渲染的图片 如果是有规律的重复出现的组件通常通过 v-for 来渲染，通过数组或对象来插入数据。比如1234567891011const data = [&#123; title: &apos;title1&apos;, img: &apos;../assets/pic01.png&apos; &#125;, &#123; title: &apos;title2&apos;, img: &apos;../assets/pic02.png&apos;&#125;]&lt;my-compo v-for=&quot;item in data&quot;&gt; &lt;img :src=&quot;item.img&quot;&gt;&lt;/img&gt;&lt;/my-compo&gt; 这样的问题是 webpack 不会对 src 做任何操作，会原样输出导致 404 错误1&lt;img src=&quot;../assets/pic01.png&quot;&gt;&lt;/img&gt; 这是因为渲染操作是在浏览器完成的。解决办法是使用 require 引入图片让 webpack 在 build 的时候就知道要处理它们1234567const data = [&#123; title: &apos;title1&apos;, img: require(&apos;../assets/pic01.png&apos;) &#125;, &#123; title: &apos;title2&apos;, img: require(&apos;../assets/pic02.png&apos;)&#125;] css自动加前缀https://github.com/MoOx/postcss-cssnext 压缩支持gzip编辑config/index1productionGzip: true webpack忽略某个文件夹的编译编辑build中的webpack.base.conf.js12345678resolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: &#123;&#125; &#125;, module: &#123; noParse: [/videojs-contrib-hls/], // 添加该行 rules: [] &#125; 问题列表 vue-cli build后 Webfonts字体路径引用出错的问题找到 webpack.base.conf.js替换 12345678&#123; test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/, loader: &apos;url-loader&apos;, query: &#123; limit: 10000, name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;) &#125;&#125; 替换为 1234&#123; test: /\.(woff|woff2|eot|ttf|svg)(\?.*$|$)/, loader: &apos;url-loader?importLoaders=1&amp;limit=100000&apos;&#125; 解决方法参考自 github]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-cli</tag>
      </tags>
  </entry>
</search>
